---
title: "CameraGLM"
output:
  html_document: default
  pdf_document: default
    # fig.width: 6
    # fig.height: 4
    # highlight: pygments
  word_document:
    reference_docx: "cam_GLM_templ.docx"
date: "2023-08-30"
editor_options:
  markdown:
    wrap: 70
---

```{r include=FALSE}
remove(list=ls())
while (!is.null(dev.list()))  dev.off()

# to make PDFs, need LaTex installed 
# install tinytex package, THEN run tinytex::install_tintytex()

# Note that the horizontal lines help in the HTML output, but are overkill in pdf
# Also, in HTML the differences in the heading types are much more exaggerated
# In PDF, the extra \n in the code blocks aren't needed, although they make the 
# console output more readable in the script itself
# don't actually want to squeeze a large png into a small image size?
# but the table font size seems to scale with image size
# changing the dpi argument in knitr::include_graphics is the only thing that worked to change image output size
# always turn off chunks before commenting out code or deleting
# Also remember that comments in the text sections have open and close characters
```

```{r setup, include=FALSE}
# setwd("C:/Users/sarah/Dropbox/Coursework/dissertation/ch1_analysis/")

knitr::opts_chunk$set(echo = FALSE,
                      message=FALSE,
                      # out.width = "1000px",
                      fig.width = 6, # these should set the dims for knitr figs
                      fig.height = 4,
                      tidy.opts = list(width.cutoff = 89), 
                      tidy = TRUE)

# This script runs various GLMs using the camera fate data
# I've included the code for the fate misclassification function for reference


#library(Amelia)
library(stats)
library(tidyverse)
library(car)
library(gtsummary)
library(AICcmodavg)
library(gt)
library(effects)
library(ggpubr)
library(cowplot)
library(formatR)
```

----------------------------------------------------------------------

<!-- notes: what is the correlation between variables -->

<!-- AIC table including first-order interactions, correlation matrix for -->

<!-- best model or set of best models: - misclassification vs classification -->

<!-- can do 2 separate analyses: H vs F and then take out H and look at -->

<!-- classification of failure -->

<!-- I'm still not totally sure what this second analysis would entail -->

<!-- analysis of fates - put it in a table -->

# \* \* BACKGROUND \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*

This script sets up and runs a series of GLMs.

Prepare data:

-   Examine and remove NAs
-   Make sure categorical variables are coded as factors in R
-   Create datasets with and without 2021 data so we can compare

Examine the data:

-   View frequency tables for predictor and response variables
-   View histograms of response variable for each proposed analysis
-   Check for correlation between continuous predictor variables

Run the models:

-   Create functions to simplify running so many models
-   For each proposed analysis/question:
    -   examine output of univariate model for each predictor
    -   create full, null, and nested models with explanations
    -   generate odds ratios and AIC table

# \* \* PREPARE THE DATA \* \* \* \* \* \* \* \* \* \* \* \* \*

## Read in the data.

```{r include=FALSE}

# filename <- "model_data/all_nest_data_GLM_0906_0949_.csv"
# ndGLM_   <- read_csv(filename )
nestData <- read_csv("nest_data/nest_data_cleaned0918_1659_.csv",
                     col_types = cols(.default="c"))
# now there are both numeric and character columns for final fate and cam fate

# now = format(Sys.time(), "%m%d_%H%M_")

nestData <- nestData |>  # yet another new column
  mutate(fate = ifelse(final_fate==8, 1, final_fate))

```

## Data wrangling

First, we will select only the nests with cameras, because the
response variable is fate misclassification (difference between camera
and field fate).

We then reduce back to one row per nest by condensing the observation
history to one cell.

```{r message=FALSE}
# somewhere in here, obs_int becomes 0 for all rows
# but it was working before...

ndGLM <- nestData %>% 
  filter(camera == TRUE) %>% 
  group_by(nest, site, species) %>%   
  select(nest, site, species, cov_5m, fate_date, nest_age, obs_int, i, j, k, final_fate, fate, cam_fate, cfate, status, year )%>%
  summarize(status = list(status), 
            across(where(is.integer), last), # now they are all chr
            across(where(is.numeric), last),
            # across(where(is.character), first) # which ones actually need the 1st?
            across(where(is.character), last)
            # vars that change value btw rows: obs_int, status
  ) %>%
  mutate_if(is.list, ~paste(unlist(.), collapse = '|'))

ndGLM <- ndGLM %>%
  filter(site %in% c("RUTW", "RUTE")) %>%
  filter(species %in% c("CONI", "LETE"))

ndGLM$fdate <- ndGLM$k
```

```{r eval=FALSE, message=FALSE, include=FALSE}
# ndGLM$k <- as.numeric(ndGLM$k) + 3 # add 3 if not re-running clean_format.R
camFateNA    <- ndGLM$nest[which(is.na(ndGLM$cam_fate))]  # 44 total
# ndGLM$nest[which(is.na(ndGLM$cam_fate))]
# fate_dateNA  <- ndGLM$nest[which(is.na(ndGLM$fate_date))] # 50 total
fdateNA      <- ndGLM$nest[which(is.na(ndGLM$k))]
# is fate date when fate was assigned, or when fate occurred?
# estHD_NA <- ndGLM$nest[which(is.na(ndGLM$))]

nest_ageNA   <- ndGLM$nest[which(is.na(ndGLM$nest_age))]  # 66 total
# now 52
# 2019: 7,  2020: 4,  2021: 25
# not adding up
# allNA <- union(camFateNA, fate_dateNA)
allNA <- union(camFateNA, fdateNA) # changing to k doesn't reduce # NAs D:
# reduced to 36, but goes back to 48 when you add nest_age NA
allNA <- union(allNA, nest_ageNA) # 53 total nests to exclude-that's about a third
```


```{r eval=FALSE, message=FALSE, include=FALSE}
# ndGLM$k[ndGLM$nest==30935] = 87
ndGLM$k[ndGLM$nest==30935] = 77 # subtract 10
ndGLM$k[ndGLM$nest==30934] = 74
ndGLM$k[ndGLM$nest==30959] = 81 
ndGLM$k[ndGLM$nest==20305] = 61
ndGLM$k[ndGLM$nest==10242] = 40
# ndGLM$k[ndGLM$nest==]

ndGLM$nest_age[ndGLM$nest==10242] = 10
ndGLM$nest_age[ndGLM$nest==20305] = 16
ndGLM$nest_age[ndGLM$nest==30935] = 16
ndGLM$nest_age[ndGLM$nest==30959] = 16

ndGLM$cam_fate[ndGLM$nest==30909] = 2
ndGLM$cam_fate[ndGLM$nest==30914] = 0
ndGLM$cam_fate[ndGLM$nest==30916] = 0
ndGLM$cam_fate[ndGLM$nest==30933] = 1
ndGLM$cam_fate[ndGLM$nest==30934] = 0
ndGLM$cam_fate[ndGLM$nest==30420] = 0
ndGLM$cam_fate[ndGLM$nest==30301] = 1
ndGLM$cam_fate[ndGLM$nest==30903] = 0
ndGLM$cam_fate[ndGLM$nest==30906] = 0
ndGLM$cam_fate[ndGLM$nest==30910] = 0
ndGLM$cam_fate[ndGLM$nest==30931] = 5
ndGLM$cam_fate[ndGLM$nest==30932] = 1
# ndGLM$cam_fate[ndGLM$nest==30909] = 2


```
```{r}
 # mutate(final_fate = case_match(final_fate,
 #                                 "H"   ~ 1, 
 #                                 "F"   ~ 0, 
 #                                 "F-A" ~ 0,
 #                                 "D"   ~ 2,
 #                                 "D-A" ~ 2,
 #                                 "S"   ~ 3,
 #                                 "A"   ~ 4,
 #                                 "Hu"  ~ 5,
 #                                 "Ca"  ~ 6,
 #                                 "U"   ~ 7,
 #                                 "U?"  ~ 7,
 #                                 "U-H" ~ 8
 #         ),
 #         
 #         cam_fate = case_match(cam_fate,
 #                               "H"  ~ 1, 
 #                               "F"  ~ 0, 
 #                               "D"  ~ 2,
 #                               "S"  ~ 3,
 #                               "A"  ~ 4,
 #                               "Hu" ~ 5,
 #                               "Ca" ~ 6,
 #                               "U"  ~ 7
```

```{r message=FALSE}
table(ndGLM$species)
# ndGLM <- ndGLM %>% count(species)
table(ndGLM$site)
table(ndGLM$year)
# missing some from 2019????
# ndGLM$nest[which(ndGLM$year=="2019")]
# I think I'm just going crazy
table(ndGLM$cfate)
# table(ndGLM$cam_fate)
 
```

## Add variables representing misclassification.

-   Combine some levels of the cam_fate variable and make sure it's coded as a factor with correct number of levels.

```{r}
# need to change both the numeric and letter versions of camera fate var
# ndGLM <- ndGLM |>
  # mutate(cam_fate = case_match(),
         # cfate    = case_when())

ndGLM$cam_fate[ndGLM$cam_fate == 6] = 5
ndGLM$cfate[ndGLM$cfate == "Ca"] = "Hu"
```


```{r eval=FALSE, include=FALSE}
table(ndGLM$cam_fate)
table(ndGLM$cfate) # the rest of the 7's are probably NA? yes.

sum(is.na(ndGLM$cfate))
```

```{r}
# from andes et al. 2019 - types of misclassification
# (1) probable successful or unknown/undetermined by field evidence and
#  failed by camera 206 and (2) failed or unknown/undetermined by field
#   evidence and successful by camera
```

-   Create functions to label nests as misclassified or not.

```{r}
howMis <- function(fate, c_fate){
  case_when(
    fate %in% c(0:6)  & c_fate != fate        ~ "M", # fate    -> other 
    # fate %in% c(7,8)  & c_fate %in% c(0:6)    ~ "N", # unknown -> other
    fate %in% c(7:9)  & c_fate %in% c(0:6)    ~ "N", # unknown -> other
    fate %in% c(0:6)  & c_fate == 7           ~ "U"  # unknown cam fate
  )
}
```

-   Variable for nest misclassification based on hatch or fail, not
    multiple failure causes.

Where does unknown fate fit into this? In one paper, they had a third
category, but could it just be misclassified?

```{r}
ndGLM <- ndGLM %>% 
  mutate(hatchfail = case_when(
    final_fate %in% c(0, 2:6) ~ 0, # fail
    final_fate == 1           ~ 1, # hatch
    final_fate == 7           ~ 7,
    final_fate == 8           ~ 1, # make U-H into H, because we tend to do that
    final_fate == 9           ~ 0,
    # final_fate == NA          ~ 7 # MAKE SURE all of these are coding correctly
    is.na(final_fate)          ~ 7 # MAKE SURE all of these are coding correctly
  ))

table(ndGLM$hatchfail)
```


```{r}
ndGLM <- ndGLM %>% 
  mutate(c_hatchfail = case_when(
    cam_fate %in% c(0, 2:6) ~ 0,
    cam_fate == 1           ~ 1,
    cam_fate == 7           ~ 7,  # hopefully not many/any of either of these
    #cam_fate == NA          ~ 7   # this one doesn't work - oh duh
    # is.na(cam_fate)         ~ 7
    is.na(cam_fate)         ~ 7
    # remove cam_fate == 7?
  ))

table(ndGLM$c_hatchfail)
```

```{r}
ndGLM <- ndGLM %>% 
  mutate(HF_mis = case_when(
    # c_hatchfail == 7 | hatchfail == 7 ~ NA,
    hatchfail   == 7 & c_hatchfail != 7 ~ 1, # nest was misclassified
    c_hatchfail == hatchfail ~ 0, # nest wasn't misclassified
    c_hatchfail != hatchfail ~ 1  # nest was misclassified
  )) #%>%
```

```{r message=FALSE}

fates <- ndGLM %>% 
  select(nest,final_fate,cam_fate, hatchfail, c_hatchfail, HF_mis, nest_age, fdate, fate_date)

```

-   Variable for nest misclassification including all fate categories.

-   Variable for how the nest was misclassified (correct, newly assigned
    from unknown, incorrect)

```{r}
ndGLM <- ndGLM %>% 
  mutate(misclass = case_when(
    cam_fate == 7 ~ NA,
    # final_fate == cam_fate ~ 1, # nest wasn't misclassified
    fate == cam_fate ~ 0, # nest wasn't misclassified
    fate != cam_fate ~ 1   # nest was misclassified
  ) ) %>%
  mutate(how_mis = 
           # case_when(misclass==0                 ~ howMis(final_fate, cam_fate),
           case_when(misclass==1                 ~ howMis(final_fate, cam_fate),
                     # misclass==1 & final_fate==7 ~ "U", 
                     misclass==0 & final_fate==7 ~ "U", 
                     misclass==0 & final_fate!=7 ~ "C"))

# ndGLM$misclass

# ndGLM$how_mis
```

-   Visually inspect new fate categories for discrepancies.

```{r message=FALSE}

fates2 <- ndGLM %>% 
  select(nest,final_fate,cam_fate, misclass, how_mis, hatchfail, c_hatchfail, HF_mis, nest_age, fdate, fate_date)

```
```{r}
table(ndGLM$cam_fate)
```

-   Create new variable (1/0), assigned fate in field or not

```{r include=FALSE}
isU <- function(fate) ifelse(fate %in% c(7:9), 1, 0)

# ndGLM2 <- ndGLM2 |> mutate(is_u = isU(final_fate))

```

## Examine data; find and remove missing values (NA).

-   Ungroup dataframe and make categorical variables into factors;
    make sure other data classes are correct

```{r}
ndGLM_ <- as.data.frame(ndGLM) # make into a regular df (not grouped)
ndGLM_ <- ndGLM_ |> mutate(
  across(c(obs_int, fate_date, nest_age, cov_5m, fdate), as.numeric)
  # across(c(species, cam_fate, cfate, HF_mis, misclass, how_mis, is_u), as.factor)
)

ndGLM_ <- ndGLM_ |> mutate(is_u = isU(final_fate)) |>
  mutate(c.fate    = cam_fate,
         cam_fate = as.character(cam_fate)) |>
  mutate(cam_fate = ifelse(is.na(cfate), NA, cam_fate)) |>
  mutate(cam_fate = case_match(cam_fate,
                               "0" ~ "F",
                               "1" ~ "H",
                               "2" ~ "D",
                               "3" ~ "S",
                               "4" ~ "A",
                               "5" ~ "Hu",
                               "7" ~ "U"
    
  ))
```

```{r}
# cat("Categorical predictor variables:\n")
# table(ndGLM_$species)
# ndGLM_ |>
#   group_by(cam_fate) |>
#   summarize(freq=n()) |>
#   mutate(across(c(cam_fate, freq), as.numeric)) |>
#   t() |>
#   prmatrix(collab=rep(" ",8))

# table(ndGLM_$species, ndGLM_$HF_mis)

# cat("\n\nPossible response variables:")

# res <- ndGLM_ |> tbl_summary(include=c(is_u, HF_mis, misclass),
                             # label=list(is_u ~ "Unknown in field",
                                        # HF_mis ~ "Misclassified (H/F)",
                                        # misclass ~ "Misclassified (all fates)"))

# cat("Continuous predictor variables:\n")
# # ndGLM_ |> group_by(obs_int, nest_age) |> summarize(freq = n())
# # obs <- ndGLM_ |> 
# ndGLM_ |> 
#   group_by(obs_int) |> 
#   summarize(freq=n()) |> 
#   t() |> 
#   prmatrix(collab=rep(" ",13))
# 
# ndGLM_ |> 
#   group_by(fate_date) |> 
#   summarize(freq=n()) |> 
#   t() |> 
#   prmatrix(collab=rep(" ",55))
# 
# ndGLM_ |> 
#   group_by(obs_int) |> 
#   summarize(freq=n()) |> 
#   t() |> 
#   prmatrix(collab=rep(" ",13))
#|> as.matrix(dimnames=NULL)
# colnames(obs) =NULL
# ndGLM_ |> table(obs_int)
# 
# 

# for freq tables, frq function is one option
# # but others make them look nicer

# cat("\n\nPossible response variables:")
# cat("\n\t\t\t\t\t\t no yes")
# 
# # cat("------------------------------------------------------------")
# cat("\nwas nest fate unknown in the field? \t\t", table(ndGLM_$is_u))
# cat("\nwas the nest misclassified in the field? \t", table(ndGLM_$misclass))
# cat("\nwas nest misclassified? (hatch/fail only) \t", table(ndGLM_$HF_mis),"\n\n\n")
# 
# cat("All unknowns:\n\n")
# sapply(ndGLM_, function(x) sum(is.na(x)))
```

-   Examine and remove missing data (NA) for relevant variables

Including 2021: 36 nests with NA for at least one analysis variable (24%)
Excluding 2021: 20 nests (20%)

```{r echo=FALSE}

# -----------------------------------------------------------------------------
# * MISSING DATA * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
# ------------------------------------------------------------------------------


camFateNA    <- ndGLM_$nest[which(is.na(ndGLM_$cam_fate))]  # 44 total
# ndGLM$nest[which(is.na(ndGLM$cam_fate))]
fate_dateNA  <- ndGLM_$nest[which(is.na(ndGLM_$fate_date))] # 50 total
fdateNA      <- ndGLM_$nest[which(is.na(ndGLM_$k))]
# is fate date when fate was assigned, or when fate occurred?

nest_ageNA   <- ndGLM_$nest[which(is.na(ndGLM_$nest_age))]  # 66 total
# now 52
# 2019: 7,  2020: 4,  2021: 25
# not adding up
# allNA <- union(camFateNA, fate_dateNA)
allNA <- union(camFateNA, fdateNA) # changing to k doesn't reduce # NAs D:
# reduced to 36, but goes back to 48 when you add nest_age NA
allNA <- union(allNA, nest_ageNA) # 53 total nests to exclude-that's about a third


hmNA <- ndGLM$nest[which(is.na(ndGLM$how_mis))] # how can we reduce this number?

numNA <- length(allNA) # 78 total now - now down to 70 on 20 aug

NA201920 <- ndGLM_ %>% 
  filter(nest %in% allNA) %>%
  filter(year != "2021") %>%
  select(nest)                 # only 38 from 2019-2020 

ndGLM_$numNA <- numNA                     # export the counts as part of the data
ndGLM_$numNA1920 <- length(NA201920$nest) 

cat("All the missing values (with 2021):\n\n")
# sapply(ndGLM_, function(x) which(is.na(x))) # or do this by nest number
sapply(ndGLM_, function(x) sum(is.na(x)))
cat("\n\nWithout 2021:\n\n")
ndGLM_ |> filter(year %in% c(2019, 2020)) |> sapply(function(x) sum(is.na(x)))

```

<!-- * Remove the NAs. -->

```{r echo=FALSE, message=FALSE}

ndGLM1 <- ndGLM_ %>% select(!status) # remove status (list of lists)
#T/F vector of correct length (nrows)
ndGLM1$remove <- ndGLM1$nest %in% allNA # use %in% instead of ==
# write.csv(ndGLM1, sprintf("output/which_removed%s.csv", now))

ndGLM1 <- ndGLM1[ndGLM1$remove == FALSE,] # somehow I got 76 instead of 78
fates <- ndGLM1 %>% select(nest,final_fate,cam_fate,misclass,how_mis,hatchfail,c_hatchfail,HF_mis, k)

ndGLM1$obs_int[ndGLM1$obs_int > 15] = 4

ndGLM1 <- ndGLM1 |> 
  mutate(  across(c(species, cam_fate, cfate, HF_mis, misclass, how_mis, is_u), as.factor)) # do this AFTER removing all the NAs so you don't get empty levels

```

```{r}

fates3 <- ndGLM1 %>% 
  select(nest, final_fate, cam_fate, misclass, how_mis, hatchfail, c_hatchfail, HF_mis, nest_age, fdate, fate_date, is_u)

```

-   Create new dataset w/o 2021

```{r include=FALSE}
# Leads to a completely different order of models for BIC and AICc
ndGLM2 <- ndGLM1[ndGLM1$year!="2021",] # data with 2021 removed - less than half
```

## Create frequency tables for vars in nest data

```{r echo=FALSE, message=FALSE}
# can add labels to the variables in the table, or beforehand via attr from labelled package
  
fr_tab <- function(data){

  pre1 <- data |>
    
    mutate(HF_mis = HF_mis == 1) |>                            # response var # 1

    tbl_summary(by=HF_mis,
                include=c(species, cfate),
                # value=list()
                type=list(where(is.logical) ~ "categorical"), #doesn't work
                # try converting to T/F earlier?
                label=list(species ~ "Species",
                           # cam_fate ~ "True fate (from camera)")) |>
                           cfate ~ "Camera fate")) |>
    modify_header(label ~ "**Variable**", 
                  all_stat_cols() ~ "**{level}**<br>(N={n})") |>

    modify_spanning_header(c("stat_1", "stat_2") ~ "**Nest misclassified (H/F)**") |>
    bold_labels()
  # pre1  
  # try using tbl_strata instead of merging 3 tables
  # I don't think it will work bc these are 3 different vars
  # unless I made them levels of a factor?
  pre2 <- data |>
    mutate(misclass = misclass == 1) |>                       # response var # 2
    
    # mutate(across(c(HF_mis, misclass, is_u), as.logical)) |>
    # mutate(HF_mis = as.logical(HF_mis)) |>
    tbl_summary(by=misclass,
                # include=c(species, cam_fate),
                include=c(species, cfate),
                # value=list()
                type=list(where(is.logical) ~ "categorical"), #doesn't work
                # try converting to T/F earlier?
                label=list(species ~ "Species",
                           cfate ~ "Camera fate")) |>
    modify_header(label ~ "**Variable**",
                  all_stat_cols() ~ "**{level}**<br>(N={n})") |>
    # modify_spanning_header(c("stat_1", "stat_2") ~ "**Was nest misclassified (H/F)?") |>
    modify_spanning_header(c("stat_1", "stat_2") ~ "**Nest misclassified (all fates)**") |>
    bold_labels()
  # pre2
  pre3 <- data |>
    mutate(is_u = is_u == 1) |>                                # response var # 3
    
    # mutate(across(c(HF_mis, misclass, is_u), as.logical)) |>
    # mutate(HF_mis = as.logical(HF_mis)) |>
    tbl_summary(by=is_u,
                include=c(species, cfate),
                # value=list()
                # type=list(where(is.logical) ~ "categorical"), #doesn't work
                # try converting to T/F earlier?
                label=list(species ~ "Species",
                           cfate ~ "Camera fate")) |>
    modify_header(label ~ "**Variable**", 
                  all_stat_cols() ~ "**{level}**<br>(N={n})") |>
    # modify_spanning_header(c("stat_1", "stat_2") ~ "**Was nest misclassified (H/F)?") |>
    modify_spanning_header(c("stat_1", "stat_2") ~ "**Marked unknown in field**") |>
    bold_labels()
  # pre3
  
  pr <- tbl_merge(tbls=list(pre1,pre2,pre3),
                  tab_spanner = c("**Misclassified (H/F)**",
                                  "**Misclassified (all fates)**",
                                  "**Marked unknown**"))
  pr <- pr |> as_gt() |> 
    cols_width(variable ~ px(250)) |>
    tab_options(container.width=900,
                container.height=600)
  # pr
  now = format(Sys.time(), "%m%d_%H%M_")
  # pr
  # pr |> gtsave(filename=sprintf("images/frtab_w2021_%s.png", now))
  filename <- ifelse(
    "2021" %in% data$year,
    sprintf("frtab_inc2021_%s.png", now),
    sprintf("frtab_no2021_%s.png", now)
  )
  # filename <- sprintf("frtab_w2021_%s.png", now)
  # gtsave(pr, filename=sprintf("frtab_w2021_%s.png", now), path="images/")
  pr |> gtsave(filename=filename, path="analysis/", vwidth=1200, vheight=800)
  
  return(filename)
}
```

## Frequency table including 2021

```{r echo=FALSE, message=FALSE, fig.dim = c(6,4)}

filename <- fr_tab(ndGLM1)
# knitr::include_graphics("analysis/frtab_w2021_0915_0955_.png")
knitr::include_graphics(paste0("analysis/", filename),
                        # dpi=(1160/6)) # width (px) / desired width (in)
                        dpi=(1300/6)) # width (px) / desired width (in)
                        # make it a little narrower

# why are there so few nests with fate S?
# what is the most appropriate way to combine fate categories given that some are too small? what question will I actually be answering?
#################################################################################

# for printing to console:

# cat("DATA INCLUDING 2021\n")
#cat("Categorical predictor variables:\n")
# table(ndGLM1$species)
# cat("\ntrue fate (according to camera footage)")
# table(ndGLM1$cam_fate) 
# cat("\n\nPossible response variables:")
# cat("\n\t\t\t\t\t\t no yes")
# # cat("------------------------------------------------------------")
# cat("\nwas nest fate unknown in the field? \t\t", table(ndGLM1$is_u))
# cat("\nwas the nest misclassified in the field? \t", table(ndGLM1$misclass))
# cat("\nwas nest misclassified? (hatch/fail only) \t", table(ndGLM1$HF_mis),"\n\n\n")
# cat("All unknowns:\n\n")
# sapply(ndGLM1, function(x) sum(is.na(x)))

#################################################################################
```

```{r echo=FALSE, message=FALSE, fig.dim=c(6,4)}
# fates <- ndGLM1 %>% select(nest,final_fate,cam_fate,misclass,how_mis,hatchfail,c_hatchfail,HF_mis, k)
```

## Excluding 2021

```{r echo=FALSE, message=FALSE, fig.width=6, fig.height=4}
# makes sense that there are so few "F" fate nests - if cam lets us see true fate and F is just a catch-all category
# But are they essentially U fate? could I re-code them as such because there are so few?
filename <- fr_tab(ndGLM2)
# knitr::include_graphics("analysis/frtab_no2021_0915_1039_.png")
knitr::include_graphics(paste0("analysis/",filename),
                        dpi=(1300/6)) # dpi setting = only thing that works
#################################################################################

# for printing to console:
# 
# cat("DATA EXCLUDING 2021\n")
# cat("Categorical predictor variables:\n")
# cat("\nspecies")
# table(ndGLM2$species)
# cat("\ntrue fate (according to camera footage)")
# table(ndGLM2$cam_fate)
# cat("\n\nPossible response variables:")
# cat("\n\t\t\t\t\t\t no yes")
# cat("\nwas nest fate unknown in the field?\t\t", table(ndGLM2$is_u))
# cat("\nwas the nest misclassified in the field?\t", table(ndGLM2$misclass))
# cat("\nwas nest misclassified? (hatch/fail only)\t", table(ndGLM2$HF_mis),"\n")
# cat("\n\nAll unknowns:\n\n")
# sapply(ndGLM1, function(x) sum(is.na(x)))


#################################################################################


```

# \* \* PLOTS \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*

## HISTOGRAMS

Plot the distributions of each continuous predictor with and without
2021 data. Make sure the bin sizes make sense.

### First, create a function that makes the plots.

-   Can change response variable / data for the plot without having to
    copy-paste and edit

```{r include=FALSE}

plot_var <- function(resp, dat, label1, label2){
  
  # dat <- ndGLM1
  
  dat <- dat %>% mutate(fill = !(.data[[resp]]==1))
  # , fill2 = (.dat[[v2]]==1))
  
  p1 <- ggplot(dat, aes(x=nest_age)) +  # age of nest when fate assigned
    geom_histogram(aes(fill=fill ), bins = 19) + # grouped by (mis)classification
    
    # can add lines at incubation times, not sure if necessary tho
    #geom_vline(xintercept=16, linetype="dashed", size=1, color="darkmagenta") +
    #geom_vline(xintercept=19, linetype="dashed", size=1, color="darkgoldenrod3") +
    
    xlab("nest age (days)") +
    ylab("count") +
    # scale_fill_discrete(name="",labels=c("Misclassified", "Correctly classified")) +
    scale_fill_discrete(name="",labels=c(label1, label2)) +
    # scale_fill_discrete(name="",labels=c("stuff", "things")) +
    # theme(axis.text = element_text(size=12),
    theme(axis.text = element_text(size=9),
          # axis.title = element_text(size=16),
          axis.title = element_text(size=11),
          # legend.text = element_text(size=14)
          legend.text = element_text(size=10)
    )
  
  p2 <- ggplot(dat, aes(x=fdate)) +  # day of season when fate assigned
    geom_histogram(aes(fill=fill)) + # grouped by (mis)classification
    xlab("day of season") +
    theme(axis.text = element_text(size=9), 
          axis.title = element_text(size=11),
          axis.title.y = element_blank()
    )# grouped by (mis)classification
  
  p3 <- ggplot(dat, aes(x=obs_int)) +  # day of season when fate assigned
    geom_histogram(aes(fill=fill), bins=9) + # grouped by (mis)classification
    xlab("final interval length (days)") +
    scale_x_continuous(breaks=c(0,3,6,9,12)) +
    theme(axis.text   = element_text(size=9),
          axis.title  = element_text(size=11),
          axis.title.y = element_blank()
    )# grouped by (mis)classification
  # make sure the obs_int recorded is correct
  
  # plot all side-by-side
  # p4 <- ggpubr::ggarrange(p1,p2,p3,ncol=3,common.legend = TRUE)

  # p4 + grid::grid.rect(.5,.5,width=unit(.99,"npc"),
  #                height=unit(0.99,"npc"),
  #                gp=gpar(lwd=3, fill=NA, col="#cccccc"))

  ###################
  # COWPLOT FUNCTIONS:
  # leg <- NA
  leg <- get_legend(p1 + theme(legend.position="top"))
  # p4 <- cowplot::plot_grid
  # if you use cowplot, need to make a plot merging the 3 and then a plot
  # merging that plot with the legend
  p4 <- plot_grid(p1 + theme(legend.position="none"),
                  p2 + theme(legend.position="none"),
                  p3 + theme(legend.position="none"),
                  # leg,
                  # rel_widths=c(1,1,1,.3),
                  # align="vh")
                  nrow=1)
  
  p4 <- plot_grid(p4, leg, ncol=1, rel_heights=c(1, 0.25))
  # Warning: Graphs cannot be vertically aligned unless the axis parameter is set.
  # Placing graphs unaligned.
  # Warning: Graphs cannot be horizontally aligned unless the axis parameter is set.
  # Placing graphs unaligned.
  p4 <- ggdraw(p4) +
    theme(plot.background = element_rect(color = "#cccccc"), # border for combined plot
          # plot.margin = 13) # plots nothing
          # plot.margin = unit(c(5,5,5,5), "mm")) # plots nothing
          plot.margin = margin(1,1,0,1, "cm")) # plots nothing
  ###########
  
  p4
}
```

<!-- ### First analysis: hatch/fail misclassification -->
### Nest fate misclassification

-   Ends up with NAs for nests w/ unknown fate in the field

```{r echo=FALSE, message=FALSE, fig.dim=c(6,3)}
# plot_var("HF_mis", ndGLM1, "Misclassified", "Correctly classified")
plot_var("misclass", ndGLM1, "Misclassified", "Correctly classified")
``` 

```{r echo=FALSE, message=FALSE, fig.dim=c(6,3)}
# plot_var("HF_mis", ndGLM2, "Misclassified", "Correctly classified")
plot_var("misclass", ndGLM2, "Misclassified", "Correctly classified")
```

<!-- ### Second analysis: if failed, correct or not -->

<!-- ```{r echo=FALSE, message=FALSE, fig.dim=c(6,3)} -->
<!-- ndGLM_f <- ndGLM1[ndGLM1$c_hatchfail != 1,] -->
<!-- # plot_var( "how_mis", ndGLM1[ndGLM1$c_hatchfail != 1,]) -->
<!-- plot_var( "HF_mis", ndGLM1[ndGLM1$c_hatchfail != 1,], "Missclassified", "Correctly classified") -->
<!-- ``` -->

<!-- ```{r echo=FALSE, message=FALSE, fig.dim=c(6,3)} -->
<!-- ndGLM_f2 <- ndGLM2[ndGLM2$c_hatchfail != 1,] -->
<!-- plot_var( "HF_mis", ndGLM2[ndGLM2$c_hatchfail != 1,], "Missclassified", "Correctly classified") -->
<!-- ``` -->

<!-- ### Third analysis: assigned vs unknown -->
### Assigned vs unknown

```{r echo=FALSE, message=FALSE, fig.dim=c(6,3)}
plot_var("is_u", ndGLM1, "Unknown", "Assigned")
```

```{r echo=FALSE, message=FALSE, fig.dim=c(6,3)}
plot_var("is_u", ndGLM2, "Unknown", "Assigned")
```

<!-- ### Fourth analysis: if assigned, correct or not -->

<!-- ```{r echo=FALSE, message=FALSE, fig.dim=c(6,3)} -->


<!-- ``` -->

## CORRELATION PLOTS

-   Check for correlation amongst continuous predictors

<!-- -   With and without 2021 data -->

<!-- I don't think the p-values are adding anything, since there is no -->
<!-- correlation? -->

```{r}
dat <- ndGLM1
dat2 <- ndGLM2

label_ <- function(y) max(dat[[y]]) * 0.8
```

### Fate date vs obs int

```{r echo=FALSE, warning=FALSE, fig.dim=c(6,4)}
# ```{r echo=FALSE, warning=FALSE, out.width="75%"}

ggplot(dat, aes(x=fdate, y=obs_int)) +
  geom_point() +
  geom_smooth(formula=y~x,
              method="lm") +
  ggtitle("Including 2021") +
  stat_regline_equation(formula=y~x,
                        label.y=0.8*max(dat$obs_int), # label.y = vertical position
                        aes(label=..eq.label..)) + 
  stat_cor(aes(label=paste(..rr.label.., ..p.label.., sep="*`,`~"))) +
  # theme(plot.background = element_rect(color="deepskyblue3", linewidth=2, alpha=0.5))
  # theme(plot.background = element_rect(color="#707070", linewidth=2 ))
  theme(plot.background = element_rect(color="#cccccc", linewidth=1 ))
```

```{r echo=FALSE, warning=FALSE, fig.dim=c(6,4)}
ggplot(dat2, aes(x=fdate, y=obs_int)) +
  geom_point() +
  geom_smooth(formula=y~x,
              method="lm") +
  ggtitle("Excluding 2021") +
  stat_regline_equation(formula=y~x,
                        label.y=0.8*max(dat$obs_int), # label.y = vertical position
                        aes(label=..eq.label..)) + 
  stat_cor(aes(label=paste(..rr.label.., ..p.label.., sep="*`,`~"))) +
  theme(plot.background = element_rect(color="#cccccc", linewidth=1 ))
```

### Nest age vs fate date

```{r echo=FALSE, fig.dim=c(6,4)}
ggplot(dat, aes(x=nest_age, y=fdate)) +
  geom_jitter() +
  geom_smooth(formula=y~x,
              method="lm") +
  ggtitle("Including 2021") +
  stat_regline_equation(formula=y~x,
                        label.y=0.8*max(dat$fdate), # label.y = vertical position
                        aes(label=..eq.label..)) + 
  stat_cor(aes(label=paste(..rr.label.., ..p.label.., sep="*`,`~"))) +
  theme(plot.background = element_rect(color="#cccccc", linewidth=1 ))
```

```{r echo=FALSE, fig.dim=c(6,4)}
ggplot(dat2, aes(x=nest_age, y=fdate)) +
  geom_jitter() +
  geom_smooth(formula=y~x,
              method="lm") +
  ggtitle("Excluding 2021") +
  stat_regline_equation(formula=y~x,
                        label.y=0.8*max(dat$fdate), # label.y = vertical position
                        aes(label=..eq.label..)) + 
  stat_cor(aes(label=paste(..rr.label.., ..p.label.., sep="*`,`~"))) +
  theme(plot.background = element_rect(color="#cccccc", linewidth=1 ))

```

### Nest age vs obs int

```{r echo=FALSE, fig.dim=c(6,4)}
ggplot(dat, aes(x=nest_age, y=obs_int)) +
  geom_jitter() +
  geom_smooth(formula=y~x,
              method="lm") +
  ggtitle("Including 2021") +
  stat_regline_equation(formula=y~x,
                        label.y=0.8*max(dat$obs_int), # label.y = vertical position
                        aes(label=..eq.label..)) + 
  stat_cor(aes(label=paste(..rr.label.., ..p.label.., sep="*`,`~"))) +
  theme(plot.background = element_rect(color="#cccccc", linewidth=1 ))
```

```{r echo=FALSE, fig.dim=c(6,4)}
ggplot(dat2, aes(x=nest_age, y=obs_int)) +
  geom_jitter() +
  geom_smooth(formula=y~x,
              method="lm") +
  ggtitle("Excluding 2021") +
  stat_regline_equation(formula=y~x,
                        label.y=0.8*max(dat$obs_int), # label.y = vertical position
                        aes(label=..eq.label..)) + 
  stat_cor(aes(label=paste(..rr.label.., ..p.label.., sep="*`,`~"))) +
  theme(plot.background = element_rect(color="#cccccc", linewidth=1 ))

#  When is it OK to use jitter instead of point?
```

# \* \* MODELS \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*

## FUNCTIONS

Make a univariate model from each predictor variable.\
Print the summaries of all univariate models

<!-- (should I add ANOVA for each as well?) -->

```{r include=FALSE}
# univar_mod <- function(resp, modData, modsumORmodtab ){
univar_mod <- function(resp, modData ){ # not sure how to return one or the other - just return both
  # browser()
  vars <- c("species", "nest_age", "cam_fate", "fdate", "obs_int")
  # vars <- c("species", "nest_age", "cfate", "fdate", "obs_int")
  umod_ <- list()
  for(v in seq_along(vars)){
    f <- paste0(resp," ~ ", vars[v])
    # cat(f,"\n\n")
    cat(f,"\t")
    umod_[[v]] <- glm(f, data=modData, family=binomial)
  }
  modsum <- list()
  
  for(i in 1:5){
    modsum[[i]] <- summary(umod_[[i]])
  }
  # return(modsum_)

# modData <- ndGLM1
# resp    <- "HF_mis"
  # browser()
  modtab <- modData |> 
  # select(c("misclass","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  # select(paste(nm(resp), c("species", "nest_age", "cam_fate", "fdate", "obs_int"))) |>
    select(c(resp, "species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
    tbl_uvregression(
    
      method       = glm,
      y            = resp,
      method.args  = list(family=binomial),
      exponentiate = TRUE
    
  )
  # return(broom::tidy(modsum_))
  
  # for(i in 1:length(vars)){
  #   
  #   umod_[[i]] |>
  #     select(formula, coefficients, )
  #   
  # }
  # modtab <- gt(modtab) # not working
  modtab <- as_gt(modtab)
  # Error in UseMethod("group_vars") : 
  # no applicable method for 'group_vars' applied to an object of class
  #  "c('tbl_uvregression', 'gtsummary')"
  
  modinfo = list(modsum, modtab)
  # modinfo = list(modsum, as.gt(modtab))
  # modinfo = list(modsum, gt(modtab))
  return(modinfo )
}
# nm(resp)
```

Compare coefficients of any 2 different models

```{r include=FALSE}
# mod_diff <- function(mod1, mod2){

# maybe eventually add the argument for the print statement, if time
# could use "full" as default value and only change for the interaction models

# mod_diff <- function(mFull, mAlt, modtype){ # argument order matters - names should help
mod_diff <- function(mFull, mAlt, modtype){ # argument order matters - names should help
  
  difVList <- which(!(names(coef(mFull))) %in% names(coef(mAlt)))
  
  # cat("\npercent difference in model coefficients (vs full model):\n")
  # cat("\n---------------------------------------------------------------")
  # cat("\n\nPercent difference in model coefficients (vs full model):\n\n") # for printing to the console

  # cat("Compare to full model:\n\n")
  comp <- anova(mFull, mAlt, test="LRT")
  # cat("Compare to full model:\n\n", comp)
  # **argument 1 (type 'list') cannot be handled by 'cat'**
  # # try cat(unlist(x))
  # cat(sprintf("Compare to %s model:\n\n"), modtype)
  cat("\nCompare to full or main effects model:\n\n")
  print(comp)
  # for(i in 1:length(comp)) cat(comp[i])
  # for(i in 1:length(comp)) rende(comp[i])
  # cat("Compare to full model:\n\n", unlist(paste(comp, sep=" "))) # this doesn't have the nice formatting
  # comp
  # cat(sprintf("\n\nPercent difference in model coefficients (vs %s model):\n\n"), modtype)
  # difff <- names(coef(mFull))[-difVList] # don't store the names
  # cat("\n\nPercent difference in model coefficients (vs full model):\n\n", difff)
  cat("\n\nPercent difference in model coefficients (vs full or main effects model):\n\n")
  cat(names(coef(mFull))[-difVList], "\n")
  cat((abs(coef(mAlt)-coef(mFull)[-difVList]) / coef(mFull)[-difVList])) #
  cat("\n---------------------------------------------------------------")
  # cat("\nCompare to null model:\n\n")
  # anova(mNull, mAlt, test="LRT") # add an mNull variable
  
  # return(list(comp, difff)) # I don't think I need these for anything
}

```

Generate odds ratios

```{r include=FALSE}
odd_rat <- function(mods){
  # cat("Odds ratios for all models:\n\n")
  # oddrats <- paste(sapply(modsC, function(x) exp(x$coefficients)), sep=' ')
  oddrats <- paste(sapply(mods, function(x) exp(x$coefficients)), sep=' ')
  # oddrats
  # names(oddrats) <- sapply(oddrats, function(x) substitute(oddrats))
  names(oddrats) <- paste0("OR_mod",seq_along(mods))
  # cat(paste(oddrats, sep="\n\n"))
  return(oddrats)
}
```

Calculate AIC and BIC

```{r eval=FALSE, include=FALSE}
dp <- function(x) deparse(x, width.cutoff=150)

bic_mod <- function(mods){
  
  modEQ <- paste(sapply(modsC,  
                        function(x) str_extract(dp(x$call), "(?<=~\\s).+(?=,\\sf)")
                        ), sep = " ")
  
  nestBIC <- bictab(cand.set = mods, modnames = modEQ, sort = T) # include VIF?
  
  BICtab <- gt(nestBIC) |> 
    tab_header(title="BIC scores") |>
    tab_style(style = 
                cell_text(size="small"),
              locations = cells_body())
  return(BICtab)
}
```

```{r include=FALSE}
dp <- function(x) deparse(x, width.cutoff=150)
aic_mod <- function(mods){
  
  # mods <- modsF
  # mods[[1]]$call 
  mods <- modsHF
  modEQ <- paste(sapply(mods,  
                        # function(x) str_extract(dp(x$call), "(?<=~\\s).+(?=,\\sf)")
                        function(x) str_extract(dp(x$call), "(?<=~\\s).+(?=\")")
                        ), sep = " ")
  modEQ
  # if(sapply(grepl("*", ))
  # lapply(modEQ, function(x) sapply(x, grep("*")))
  # eq <- lapply(modEQ, grep, pattern="*")
  # 
  # 
  # if(lapply(modEQ, grepl, pattern="*")) # doesn't work
  # 
  # n <- grep("[:alpha:]", modEQ)
  # m <- grep("\\s\\*\\s", modEQ) # works
  # m <- grep("[\w]\\s\\*\\s[\w]", modEQ) # doesn't work - I don't think this is R syntax
  # m <- grep("\\w\\s\\*\\s\\w", modEQ) # works
  # m <- regexpr("\\w\\s\\*\\s\\w", modEQ) # gives a different output
  # m <- str_extract(modEQ, "\\w\\s\\*\\s\\w")
  # could also do grep with value=TRUE
  # m <- str_extract(modEQ, "\\w+\\s\\*\\s\\w+")
  
  # m <-paste0( str_match(modEQ, "(\\w+)\\s\\*\\s(\\w+)")[,1], collapse="|")
  # I don't think collapsing the strings helps me. 
  
  m <- gsub(" ", "\\\\s", str_match(modEQ, "(\\w+)\\s\\*\\s(\\w+)") )
  m
  
  m[,1]
  # this function operates on each instance of the pattern separately
  r <- function(eq) {
    # browser()
    # t <- m[11,1]
    # m <- str_match(modEQ, eq)
    # m is evaluating to a single string of NA (not a matrix)
    # oh right, str_match requires a regex pattern
    # I can do that, but what becomes my function argument?
    # m <- str_match(modEQ, "(\\w+)\\s\\*\\s(\\w+)")
    # m[which(m[,1]==eq),] # this isn't doing anything to help select the correct thing to replace
    # r = m[which(m[,1]==eq),] # this isn't doing anything period
    # r = m[,1][which(m[,1]==eq)] # this isn't doing anything period
    # r = which(m[,1]==eq) # this isn't doing anything period
    # r = which(grep(eq, )) # this isn't doing anything period
    r = which(m[,1] %in% eq)
    # r = which(match(eq, m[,1])) # arg to which is not logical
    # r = which(eq %in% m[,1]) # r still empty
    # want the row index
    paste0(m[r,2]," + ",m[r,3]," + ",m[r,2],":",m[r,3])
    
  }
  p <- r("species * obs_int") # r creates the proper replacement...
  # but it still isn't substituted in properly
  
  p <-paste0("\\b", m[,1], "\\b", collapse="|")
  p
  
  
  # with this one, for some reason, r becomes 1 when it's which(eq %in% m[,1])
  # p <- r(modEQ[11]) # this is not the correct argument - it's the whole string, not the substring we're looking for
  # eq <- modEQ[11]
  # take apart what the col2hex function etc are doing:
  # - pattern = string of all possible color names with separator character
  # -->"if you see any of these within x"
  # - replacement = function that takes a color and returns the hex code 
  # --> "replace them with the hex code using this function"
  # so what exactly is the (uncalled) argument to col2hex?? the color name
  # 
  # so for my strings:
  # - pattern = set of all possible interaction terms (R-style, with *)
  # --> if you see any of these strings in modEQ
  # - replacement = function of 
  # --> replace them using this function to calculate the expanded expression
  # argument to the function is just any of the strings in pattern
  # - need a way to match pattern to replacement
  # - can't rely on replacing in order for THIS function
  # 
  # r(m)
  # r <- paste0(m[,2]," + ",m[,3]," + ",m[,2],":",m[,3])
  # r <- paste0
  # so what is this function actually acting on?
  # 
  str_replace(modEQ, m, r )
  # string recycling error, fml 
  str_replace(modEQ, m[,1], r )
  # still doesn't work
  str_replace(modEQ, 
              paste0("\\b",m[,1],"\\b", collapse="|"), 
              r )
  str_replace_all(modEQ, p, r)
  modEQ
  # p <-str_c("\\b", m[,1], "\\b", collapse="|")
  # n <- !is.na(m)
  # for(i in 1:length(modEQ)){
  #   str_replace(modEQ, 
  #               # str_match(modEQ[i], "(\\w+)\\s\\*\\s(w+)"),
  #               m[i,1],
  #               paste0(m[i,2], "+", m[i,3], "+", m[i,2], ":", m[i,3]))
   # so this might be interpreting "paste" as a function input for replacement, except it has arguments associated 
  
  # c("apple", "duck")
  # grep( paste0("\\b",m[,1],"\\b", collapse="|"), modEQ) 
  # str_match(modEQ, paste0("\\b",m[,1],"\\b", collapse="|"))
  # str_match(modEQ, paste0(m[,1], collapse="|"))
  # need to assign it to something and allow it to work on vectors instead of in loop?
  # but even this output isn't correct...
  # modEQ <- str_replace(modEQ,
  #                      m,
  #                      paste0(m[,2],"+",m[,3],"+",m[,2],":",m[,3]))
  modEQ <- modEQ |> str_replace( 
    # str_match(modEQ, "(\\w+)\\s\\*\\s(\\w+)") ,
    m[,1],
    paste0(m[,2],"+",m[,3],"+",m[,2],":",m[,3]))
  
  str_match(modEQ, "(\\w+)\\s\\*\\s(\\w+)")[,1] 
  # maybe there are other string functions I'm just not thinking of??
  
  modEQ <- modEQ |> str_replace( 
    # str_match(modEQ, "(\\w+)\\s\\*\\s(\\w+)")[,1] ,
    str_match(modEQ, "(\\w+)\\s\\*\\s(\\w+)"),
    
    # m[,1],
    # m[11,1],
    # r[11]
    paste0(m[,2],"+",m[,3],"+",m[,2],":",m[,3])
    
    # "fdate * obs_int",
    # "fdate + obs_int + fdate:obs_int" # even these two don't work??
    # ok, shouldn't be actual strings
  )
  modEQ
  
  str_extract
  #except now modEQ has 33 entries. I can remove some, but want to know why that's happening
  #
  # \\w = word, includes alphanumeric and underscores
  # you can also name pattern groups? wonder how that might help...
}
```


```{r include=FALSE}
# m
  r <- paste0(m[,2], " + ", m[,3], " + ", m[,2], ":", m[,3])
  # for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(m[i,1], r[i], s) # doesn't work
  r
  s <- modEQ
  for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(m[i,1], r[i], s)
  grep(m[11,1], s)
  sub("(\\w+)\\s\\*\\s(\\w+)", r) # can't use something like this because it's row-specific
  # could maybe build a regex pattern that specifies the contents of r
  # s
  # maybe because s is a vector of strings? but I thought that was what it's supposed to be?
  # grep(m[11,1], unlist(s)) # nope
  # dunno if it matters that I'm using literal spaces and not \\s
  # I don't know why you can index m like a df when it is a list
  # oh, it's a matrix... kind of a weird return format??
  r
  # if(!is.na(m)) sub("\\w+\\s\\*\\s\\w+", r, modEQ) 
  #      obv doesn't work; "if" returns more than 1 value
  # 
  # which(!is.na(r)) # evidently, NA + NA != NA
  # modEQ[which(!is.na(m))] # these don't even have the same number of components...
  
  # modEQ[m[which(!is.na(m))]]
  # m[which(!is.na(m)),] # trying to find which rows in m don't have NAs
  # m[which(!is.na(m[,2]))]
  # I guess this gives the "names" of these rows, which R assumes to be the first column
  # 
  
  # modEQ[m[which(!is.na(m[,2]))]]
  # modEQ == m[which(!is.na(m[,2]))]
  # grep( m[which(!is.na(m[,2]))])
  # which(!is.na(m[2,]))
  # which(!is.na(m)) # would give row num for a df, but not for matrix
  # 
  # 
  # str_replace(modEQ, m[which(!is.na(m[,2]))]), 
  m[11,1]
  # !is.na(m[])
  # for(i in 1:length(modEQ)) if(!is.na(m[i,1])) modEQ[i] = r[i] # not quite
  # for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(m[i,1], r[i], l) # nope
  s <- modEQ
  # for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(get(m[i,1]), r[i], s)
  # this kind of does the opposite - takes string and makes into var name
  
  for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(m[i,1], r[i], s)
  a <- list()
  # for(i in 1:length(modEQ)) append(a, is.na(m[i,1])) # not working
  # so maybe the !is.na statement is not evaluating the way I think it is
  # a <- for(i in 1:length(modEQ)) which(!is.na(m[i,1]))
   
  # for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(paste(m[i,1]), paste(r[i]), s)
  for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(paste(m[i,1]), paste(r[i]), s)
  # for(i in 1:length(modEQ)) if(!is.na(m[i,1])) sub(paste0("^.*",m[i,1]), paste(r[i]), s)
  # for(i in 1:length(modEQ)) if(!is.na(m[i,1])) cat("TRUE", m[i,1]) # does appear to be finding the correct elements...
  for(i in 1:length(modEQ)) if(!is.na(m[i,1])) 
  s
  d <- as.data.frame(s)
  grep(m[11,1], s) # can't call a string pattern from a var
  n <- gsub(" ", "", m[,1]) # deletes spaces, but doesn't help
  n
  p <- paste(modEQ, sep="|", collapse="|") # not correct
  p <- paste(m, sep="|", collapse="|")
  p <- paste(m[,1], sep="|", collapse="|") # this grabs the correct strings
  p
  str_extract(modEQ, p)
  str_match(modEQ, p) # why can't it find the patterns??
  # so in this one, it's matching the first of the strings that it finds (generally "fdate")
  
  str_extract(m[,1], p)
  # str_extract_all(s, paste(gsub(" ", "", m[,1]), collapse="|"))
  # str_extract(s, paste(n, collapse="|"))
  # str_extract(s, eval(n))
  # get(n)
  # get(n[11])
  # str_match(s, paste(n, collapse="|"))
  # str_match(s, paste(n, sep="|", collapse="|")) # why does this work in my other script?
  grep(paste(m[11,1]), s)
  grep("species * obs_int", s)
  str_match("species * obs_int", s) # needs to be regex, not string
  str_extract("species * obs_int", s)
  
  grep("species*obs_int", s) # ok, so these don't work as is
  # is a string, not a pattern
  paste(m[11,1])
  class(m[11,1])
  # s is a character vector - good
  # why isn't the paste function doing what I thought it would?
  # maybe because there are spaces?
  paste(m[,1], collapse="|")
  # str_extract_all(d, paste(m[,1], collapse="|"))
  m[,1]
  # m <- grep("[:alpha:]\\s\\*\\s[:alpha:]+", modEQ) # doesn't work
  
  # m <- grep("[:LETTER:]\\s\\*\\s[:LETTER:]", modEQ) # doesn't work
  # for(i in 1:length(modEQ)) {
  #   if(grepl("\\*", modEQ[i]))
  #     grep("")
  #     sub("[:alpha:]+//s")
  # }
  # example from help page for str_replace:
  colours <- str_c("\\b", colors(), "\\b", collapse="|")
  col2hex <- function(col) {
    rgb <- col2rgb(col)
    rgb(rgb["red", ], rgb["green", ], rgb["blue", ], max = 255)
  }
  # col2hex("red")
  x <- c(
  "Roses are red, violets are blue",
  "My favourite colour is green"
  )
  str_replace_all(x, colours, col2hex)
    
  nestAIC <- aictab(cand.set = mods, modnames = modEQ, sort = T)

  AICtab <- gt(nestAIC) |> 
    tab_header(title="AIC scores") |>
    # tab_style(
      # style = cell_text
      # style = cell_text(size="small"),
      #         locations= cells_body())
    # )
    tab_options(
      # table.font.weight = "bold",
      # was going to try setting whole table to bold and then body cells to normal
      column_labels.font.weight = "bold"
    )
  return(AICtab)

```

Create combo AIC/BIC tables

```{r eval=FALSE, include=FALSE}
delta_tab <- function(nestAIC, nestBIC){
  
  ab3 <- bind_rows(nestAIC, nestBIC) %>% 
    replace(is.na(.), 0) %>%
    group_by(Modnames) %>%
    summarize(across(where(is.numeric), c(sum, mean)))
  
  deltaTab <- ab3 %>%
    select(c(Modnames, K_1, Delta_AICc_1, Delta_BIC_1, LL_2,)) %>%
    arrange(Delta_AICc_1)
  
  deltaTab1 <- gt(deltaTab) |>
    tab_header(title="Summary of Information Criteria") |>
    tab_style(style=cell_text(size="small"),
              locations=cells_body())
  return(deltaTab1)
}

full_tab <- function(nestAIC, nestBIC){
  
  ab3 <- bind_rows(nestAIC, nestBIC) 
  ab3 <- ab3 %>%
    replace(is.na(.), 0) %>%
    group_by(Modnames) %>%
    summarize(across(where(is.numeric), c(sum, mean)))
  abTab <- ab3 %>%
    select(c(Modnames, K_1, AICc_1, AICcWt_1, BIC_1, BICWt_1, LL_2))
  abTab1 <- gt(abTab) |>
    tab_header(title="Summary of Information Criteria") |>
    tab_style(style=cell_text(size="sma ll"),
              locations=cells_body())
  return(abTab1)
}

#as_word(BICtab) # output I don't know how to use
```

Save tables to file

```{r include=FALSE}
# Input DPI for gt table AIC table output:
dpi      <- (1800/6)  # img width (px) / desired img width (in)

nm       <- function(x) substitute(x)

save_tab <- function(tab){
  
  now = format(Sys.time(), "%m%d_%H%M%S") # seconds bc tables all generated in < 1 min
  # file_name <- paste0(names(tab)[1], "aicbic_", now, ".rtf")

  file_name <- paste0(nm(tab), now, ".rtf") 
  gtsave(tab, file_name, path="analysis/")
  
  file_name1 <- paste0(nm(tab), now, ".png")
  gtsave(tab, file_name1, path="analysis/")
  return(file_name1)
}
```

```{r}
# Input DPI for gt table AIC table output:
# dpi <- (1800/6)  # img width (px) / desired img width (in)
```

## PREPARE THE DATA

Center the (numerical) predictor variables (don't scale, just center)

```{r include=FALSE}
predictors <- c("nest_age", "fdate", "obs_int") # numeric predictors
ndGLM_scl1 <- ndGLM1 %>% 
  mutate(across(predictors, function(x) as.numeric(scale(x,scale=F)))) #%>%
#   mutate(cfate2 = cam_fate) %>%
#   mutate(cam_fate = cfate) 
# 
# ndGLM_scl1$cam_fate[ndGLM_scl1$cam_fate == "F"] = "U"
# ndGLM_scl1 <- ndGLM_scl1 %>%
#   mutate(cam_fate = ifelse("F", "U", cam_fate))# %>%
#   mutate(cam_fate = as.factor(cam_fate))
# make sure df is not a grouped_df or rowwise_df, or this won't work

ndGLM_scl2 <- ndGLM2 %>%
  mutate(across(predictors, function(x) as.numeric(scale(x,scale=F))))
```


```{r eval=FALSE, include=FALSE}
write.csv(ndGLM_scl1, "scaled1.csv")
write.csv(ndGLM_scl2, "scaled2.csv")
```


```{r eval=FALSE, include=FALSE}
ndGLM_scl1 <- read.csv("scaled1.csv")
ndGLM_scl2 <- read.csv("scaled2.csv")
```

```{r}
# sapply(ndGLM_, function(x) which(is.na(x))) # or do this by nest number
# sapply(ndGLM_, function(x) sum(is.na(x)))

```

## QUESTION 1: How do the predictor vars affect classification accuracy?

<!-- -   Response: misclass -->
Response: HF_mis

<!-- *Does H/F misclassification make sense to analyze?* Presumably any type -->
<!-- of failure is more similar to other types of failure than to hatch? this -->
<!-- seems to be the assumption in papers like Andes (2018) -->

## Including 2021 data

For this first model, I have included all the output, but for subsequent models I have included only a table summary of the univariate models and an AIC table for all models evaluated. I can easily have R print all the output for all models if something warrants further attention.

### Initialize - Choose the data and response var, create list to store models.

```{r}
resp    <- "HF_mis"
# resp    <- "misclass"
dataMod <- ndGLM_scl1
modsHF  <- list()
```

### Step 1: Univariate models

Analyze the relationship between each predictor variable and the response variable when the other variables are not accounted for. The output can be used in different ways depending on how you choose to do variable selection. 

The output table below shows that some categories in the camera fate predictor have ridiculous SE/confidence intervals. I think they have too few observations. I already merged cattle into human impacts, and I could merge more categories, but the question is: 
Is it better to have unreliable parameter estimates, or split the variable into fewer categories that are less informative, or just exclude the variable altogether?

```{r echo=FALSE, warning=FALSE}
# HF_inc2021 <- univar_mod(resp, dataMod, modsum)
u_inc2021 <- univar_mod(resp, dataMod)
u_inc2021[1]
# HF_inc2021[1] # this is giving weird output as HTML
# filename <- save_tab(u_inc2021[2])
tab <- u_inc2021[[2]]
filename <- save_tab(tab)

knitr::include_graphics(paste0("analysis/",filename), dpi=dpi)

```



```{r echo=FALSE}
# HF_inc2021[2]
# vars <- dataMod |> select(c("species", "nest_age", "cam_fate", "fdate", "obs_int"))
```


```{r eval=FALSE, warning=FALSE, include=FALSE}
# odd_rat(HF_inc2021)
dataMod |> 
  # select(c("misclass","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  select(c("HF_mis","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  tbl_uvregression(
    
    method       = glm,
    # y            = misclass,
    y            = HF_mis,
    method.args  = list(family=binomial),
    exponentiate = TRUE
    
  )
  
  
# sapply(vars, function(x) sum(is.na(x)))
# HF2021     <- tbl_uvregression(
# 
#   # dataMod[c("species", "nest_age", "cam_fate", "fdate", "obs_int")],
#   vars,
#   method = glm,
#   y = resp,
#   method.args = list(family = binomial),
#   exponentiate = TRUE
# 
# )

# lengths(vars)
# HF2021
```

### Step 2: Multivariate models

Method: First, I created the null and full models.  

To select variables, I opted to start with the variables with significant p-values with an arbitrary cutoff of 0.25 (cite). I then compared to the full model via a likelihood ratio test, and examined the percent change in coefficients between the full model and the reduced model. If the percent change is large, then some variables that were removed were providing explanatory power.  

I then added those variables back in one by one and again compared using LRT and percent coefficient change. If any variables did not contribute significantly to the explanatory power of the model, I removed them to create my proposed main effects model.  

To look for the presence of interactions, I first decided what interactions would make sense biologically, and then added those to the main effects model one at a time. I evaluated the difference compared to the main effects model as explained above.  

Finally, I evaluated model goodness-of-fit and calculated AIC scores to compare the remaining models.  


```{r}
m = "main effects"
modorder <- "spp+age+fate+date+int" # just a reminder so everything is neat
```

#### Null and full models

```{r echo=FALSE, warning=FALSE}
modsHF[[1]] <- glm(as.formula(paste0(
  resp,"~ species + nest_age + cam_fate + fdate + obs_int")),
  # resp,"~ species + nest_age + cfate + fdate + obs_int")), 
  data=dataMod, family=binomial) # "fitted probabilities..." warning

modsHF[[2]] <- glm(as.formula(paste0(resp,"~ 1")), data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[2]]) # don't assign or return anything from function bc I don't need the output

# mDiff <- mod_diff(modsHF[[1]], modsHF[[2]])
# need to assign it to something or it will print the output in addition to the print statement. but assigning may disable the print statement.
```

#### Other models

```{r echo=FALSE}
modsHF[[3]] <- glm(as.formula(paste0(
  resp,"~ fdate")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[3]])

modsHF[[4]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  # resp,"~ species")),
  resp,"~ fdate + obs_int")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[4]])

modsHF[[5]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  # resp,"~ species + obs_int + cam_fate")),
  resp,"~ species +fdate + obs_int")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[5]])

modsHF[[6]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  # resp,"~ species + obs_int + cam_fate")),
  resp,"~ species + nest_age + fdate + obs_int")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[6]])
```


#### Analysis, part 1: select main effects model

```{r echo=FALSE}
aicHF <- aic_mod(modsHF)
filename <- save_tab(aicHF) # cqn get filename that table was saved to
knitr::include_graphics(paste0("analysis/",filename), dpi=dpi)
```

#### Interaction models
Specify the main effects model, and compare interaction models to it.
In this case, it's the same as the full model.

```{r echo=FALSE}

modsHF[[7]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  # resp,"~ species + obs_int + cam_fate")),
  resp,"~ species * nest_age + cam_fate + fdate + obs_int")),
  # resp, "~ fdate + obs_int + cam_fate + species * nest_age")),
  data=dataMod, family=binomial)
# mod_diff(modsHF[[1]], modsHF[[7]])


modsHF[[8]] <- glm(as.formula(paste0(
  
  resp,"~ species + nest_age + cam_fate * fdate + obs_int")),
  # resp,"~ species + nest_age + cam_fate + fdate * obs_int")),
  data=dataMod, family=binomial)

# mod_diff(modsHF[[1]], modsHF[[8]])


modsHF[[9]] <- glm(as.formula(paste0(
  
  resp,"~ species + nest_age * cam_fate + fdate + obs_int"
  # resp, "~ species + obs_int + cam_fate + fdate * nest_age"
  
)), data=dataMod, family=binomial)

# mod_diff(modsHF[[1]], modsHF[[9]])


modsHF[[10]] <- glm(as.formula(paste0(
  
  # resp, "~ species + obs_int + cam_fate + species * obs_int"
  resp,"~ species + nest_age + cam_fate + fdate * obs_int"
  
)), data=dataMod, family=binomial)

# mod_diff(modsHF[[1]], modsHF[[10]])


modsHF[[11]] <- glm(as.formula(paste0(
  
  resp, "~ nest_age + cam_fate + obs_int + species * obs_int"
  
)), data=dataMod, family=binomial)

# mod_diff(modsHF[[1]], modsHF[[11]])


# modsHF[[12]] <- glm(as.formula(paste0(
#   
#   resp, "~ species + obs_int + cam_fate + species * obs_int"
#   
# )), data=dataMod, family=binomial)
# 
# mod_diff(modsHF[[1]], modsHF[[12]])
```


#### Analysis

```{r echo=FALSE}
# mods  <- modsHF[[c(7:12)]]
mods  <- modsHF[c(1, 7:11)]
aicHF <- aic_mod(mods)
filename <- save_tab(aicHF) # cqn get filename that table was saved to
knitr::include_graphics(paste0("analysis/",filename), dpi=dpi)
```

----------------------------------------------------------------------

## Question 1, excluding 2021 data

<!-- #### Initialize - Choose the data and response var, create list to store models. -->

```{r include=FALSE}
resp    <- "misclass"
dataMod <- ndGLM_scl2
modsHF  <- list()
```

#### Univariate models

```{r echo=FALSE, warning=FALSE}
# HF_no2021  <- univar_mod("HF_mis", ndGLM_scl2)
# HF_no2021  <- univar_mod(resp, dataMod)
# HF_no2021[2]
u_no2021 <- univar_mod(resp, dataMod)
# u_no2021[[1]]
# HF_inc2021[1] # this is giving weird output as HTML
tab <- u_no2021[[2]]
filename <- save_tab(tab)

knitr::include_graphics(paste0("analysis/",filename), dpi=140)
```


```{r eval=FALSE, warning=FALSE, include=FALSE}
dataMod |> 
  select(c("misclass","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  tbl_uvregression(
    
    method       = glm,
    y            = misclass,
    method.args  = list(family=binomial),
    exponentiate = TRUE
    
  )
```

#### Multivariate models

<!-- 1.  Null and full models -->
```{r}

m = "main effects"
```

```{r warning=FALSE, include=FALSE}
modsHF[[1]] <- glm(as.formula(paste0(
  resp,"~ species + nest_age + cam_fate + fdate + obs_int")),
  data=dataMod, family=binomial) # "fitted probabilities..." warning

modsHF[[2]] <- glm(as.formula(paste0(resp,"~ 1")), data=dataMod, family=binomial)

mod_diff(modsHF[[1]], modsHF[[2]])

```

<!-- 2.  Other models -->

```{r include=FALSE}
modsHF[[3]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  resp,"~ species")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[3]])
```

```{r include=FALSE}

modsHF[[4]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  resp,"~ species + cam_fate")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[4]])
```

```{r include=FALSE}

modsHF[[5]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  resp,"~ species + cam_fate + obs_int")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[5]])
```

```{r include=FALSE}

modsHF[[6]] <- glm(as.formula(paste0(
  # resp,"~ fdate")),
  resp,"~ species + cam_fate + obs_int + fdate")),
  data=dataMod, family=binomial)
mod_diff(modsHF[[1]], modsHF[[6]])
```

<!-- 3.  Interaction models -->

```{r echo=FALSE}

```

<!-- 4.  Analysis -->

```{r echo=FALSE, message=FALSE}
aicHF <- aic_mod(modsHF)
filename <- save_tab(aicHF) # cqn get filename that table was saved to
knitr::include_graphics(paste0("analysis/",filename), dpi=dpi)
```

## QUESTION 2: If nest has failed, what affects classification accuracy?

-   Remove hatched nests
-   Response: misclass

## Including 2021 data

### Initialize

Choose the data and response var, create list to store models

```{r echo=FALSE}
modsF   <- list()
resp    <- "misclass"
# resp    <- "HF_mis"
dataMod <- ndGLM_scl1[ndGLM_scl1$final_fate!=1,]
```

### Univariate models

```{r echo=FALSE, warning=FALSE}
# F_inc2021 <- univar_mod(resp, dataMod)
# F_inc2021[2]
u_inc2021 <- univar_mod(resp, dataMod)
# u_inc2021[1]
# HF_inc2021[1] # this is giving weird output as HTML
tab <- u_inc2021[[2]]
filename <- save_tab(tab)
# filename <- save_tab(u_inc2021[2])

knitr::include_graphics(paste0("analysis/",filename), dpi=140)
# dataMod |> select()
```
```{r eval=FALSE, warning=FALSE, include=FALSE}

dataMod |> 
  select(c("misclass","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  tbl_uvregression(
    
    method       = glm,
    y            = misclass,
    method.args  = list(family=binomial),
    exponentiate = TRUE
    
  )
```

### Multivariate models

####  Null and full models
```{r}

m = "main effects"
```

```{r include=FALSE}
modsF[[1]] <- glm(as.formula(paste0(
  resp,"~ species + nest_age + cam_fate + fdate + obs_int")), 
  data=dataMod, family=binomial) # "fitted probabilities..." warning

modsF[[2]] <- glm(as.formula(paste0(resp,"~ 1")), data=dataMod, family=binomial)

mod_diff(modsF[[1]], modsF[[2]])

```

####  Other models

```{r include=FALSE}
modsF[[3]] <- glm(as.formula(paste0(
  # resp,"~ obs_int")),
  resp,"~ cam_fate")),
  data=dataMod, family=binomial) # "fitted probabilities..." warning


mod_diff(modsF[[1]], modsF[[3]])
```

```{r include=FALSE}

modsF[[4]] <- glm(as.formula(paste0(
  resp,"~ cam_fate + obs_int")),
  data=dataMod, family=binomial) # "fitted probabilities..." warning


mod_diff(modsF[[1]], modsF[[4]])
```

```{r include=FALSE}

modsF[[5]] <- glm(as.formula(paste0(
  resp,"~ cam_fate + obs_int + fdate")),
  data=dataMod, family=binomial) # "fitted probabilities..." warning


mod_diff(modsF[[1]], modsF[[5]])
```

<!-- #### Interaction models -->

```{r include=FALSE}

modsF[[6]] <- glm(as.formula(paste0(
  resp,"~ cam_fate + obs_int + fdate + nest_age")),
  data=dataMod, family=binomial) # "fitted probabilities..." warning

mod_diff(modsF[[1]], modsF[[6]])
```

#### Analysis

For this analysis, because the first and second models (ranked by AIC) are so close, I would choose the model with only camera fate as the best model. I reduced the model to just cam_fate, and when I added back the next most significant variable (obs_int) the Chi-sq p-value (compared to full model) almost doubled to about 0.5. So I probably didn't need to add back the other variables, or should I do so in case they are having an effect on one of the explanatory variables?

```{r echo=FALSE}
aicF <- aic_mod(modsF)
filename <- save_tab(aicF)

knitr::include_graphics(paste0("analysis/", filename), dpi=dpi)
```

----------------------------------------------------------------------

## Excluding 2021 data

#### Initialize

<!-- choose the data and response var, create list to store models-->

```{r include=FALSE}
modsf   <- list()
resp    <- "misclass"
dataMod <- ndGLM_scl2[ndGLM_scl2$final_fate!=1,]
```

#### Univariate models

```{r echo=FALSE, warning=FALSE}
# u <- univar_mod(resp, dataMod)
# u[2]
u_no2021 <- univar_mod(resp, dataMod)
# u_no2021[1]
# HF_inc2021[1] # this is giving weird output as HTML
tab <- u_no2021[[2]]
filename <- save_tab(tab)
# filename <- save_tab(u_no2021[2])

knitr::include_graphics(paste0("analysis/",filename), dpi=140)
```

```{r eval=FALSE, warning=FALSE, include=FALSE}

dataMod |> 
  select(c("misclass","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  tbl_uvregression(
    
    method       = glm,
    y            = misclass,
    method.args  = list(family=binomial),
    exponentiate = TRUE
    
  )
```

#### multivariate models

<!-- 1.  null and full models-->
```{r}

m = "main effects"
```

```{r include=FALSE}
modsf[[1]] <- glm(as.formula(paste0(
  resp,"~ species + nest_age + cam_fate + fdate + obs_int")),
  data=dataMod, family=binomial) # "fitted probabilities..." warning

modsf[[2]] <- glm(as.formula(paste0(resp,"~ 1")), data=dataMod, family=binomial)

mod_diff(modsf[[1]], modsf[[2]])

```

<!-- 2.  other models-->

```{r include=FALSE}
modsf[[3]] <- glm(as.formula(paste0(
  # resp, "~ obs_int + fdate"
  resp, "~ nest_age + fdate"
)), data=dataMod, family=binomial)

mod_diff(modsf[[1]], modsf[[3]])
```

```{r include=FALSE}
modsf[[4]] <- glm(as.formula(paste0(
  resp, "~ obs_int + fdate + nest_age"
)), data=dataMod, family=binomial)

mod_diff(modsf[[1]], modsf[[4]])
```

```{r include=FALSE}
modsf[[5]] <- glm(as.formula(paste0(
  resp, "~ cam_fate + obs_int + fdate + nest_age"
)), data=dataMod, family=binomial)

mod_diff(modsf[[1]], modsf[[5]])
```

```{r include=FALSE}

modsf[[6]] <- glm(as.formula(paste0(
  resp, "~ nest_age"
)), data=dataMod, family=binomial)

mod_diff(modsf[[1]], modsf[[6]])
```

<!-- 3.  interaction models-->

```{r include=FALSE}
# modsf[[5]] <- glm(as.formula(paste0(
#   resp, "~ obs_int * fdate"
# )), data=dataMod, family=binomial)
# 
# mod_diff(modsf[[1]], modsf[[5]])
```

<!-- 4. analysis-->

```{r echo=FALSE}
aicf <- aic_mod(modsf)
filename <- save_tab(aicf)

knitr::include_graphics(paste0("analysis/", filename), dpi=dpi)
```
---------------------------------------------------------------------------------

## QUESTION 3: What affects whether nest is classifiable from field evidence?

-   Response: is_u

## Including 2021 data

### Initialize

Choose the data and response var, create list to store models

```{r echo=FALSE}
modsC   <- list()
resp    <- "is_u"
dataMod <- ndGLM_scl1
```

### Univariate models

```{r echo=FALSE, warning=FALSE}
# C_inc2021 <- univar_mod(resp, dataMod)
# C_inc2021[2]                               # show summaries
u_inc2021 <- univar_mod(resp, dataMod)
# u_inc2021[1]
# HF_inc2021[1] # this is giving weird output as HTML
tab <- u_inc2021[[2]]
filename <- save_tab(tab)
# filename <- save_tab(u_inc2021[2])

knitr::include_graphics(paste0("analysis/",filename), dpi=140)
```

```{r eval=FALSE, warning=FALSE, include=FALSE}

dataMod |> 
  select(c("is_u","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  tbl_uvregression(
    
    method       = glm,
    y            = is_u,
    method.args  = list(family=binomial),
    exponentiate = TRUE
    
  )
```

### Models

#### Null and full models
```{r}

m = "main effects"
```

```{r include=FALSE}
modsC[[1]] <- glm(as.formula(paste0(
  resp,"~ species + nest_age + cam_fate + fdate + obs_int")), 
  data=dataMod, family=binomial) # "fitted probabilities..." warning

modsC[[2]] <- glm(as.formula(paste0(resp,"~ 1")), data=dataMod, family=binomial)

anova(modsC[[1]], modsC[[2]], test="LRT")
# mod_diff(modsC[[1]], modsC[[2]])

```

#### Other models

```{r include=FALSE}
# significant or close to significant in univariate models
modsC[[3]] <- glm(as.formula(paste0(
  # resp, "~ species + nest_age"
  resp, "~ nest_age"
)), data=dataMod, family=binomial)
mod_diff(modsC[[1]], modsC[[3]])

```

```{r include=FALSE}
# add next most significant variable
modsC[[4]] <- glm(as.formula(paste0(
  # resp, "~ species + nest_age + obs_int"
  # resp, "~ species + nest_age + fdate"
  resp, "~ species + nest_age"
)), data=dataMod, family=binomial)

mod_diff(modsC[[1]], modsC[[4]])

```

```{r include=FALSE}
# and next
modsC[[5]] <- glm(as.formula(paste0(
  resp, "~ species + nest_age + fdate"
)), data=dataMod, family=binomial)

mod_diff(modsC[[1]], modsC[[5]])

```

```{r include=FALSE}

modsC[[6]] <- glm(as.formula(paste0(
  resp, "~ species + nest_age + fdate + obs_int"
)), data=dataMod, family=binomial)

mod_diff(modsC[[1]], modsC[[6]])
```


#### Analysis 1: main effects model

```{r echo=FALSE}
oddRat <- odd_rat(modsC)
aicTab <- aic_mod(modsC)
# aicTab

filename <- save_tab(aicTab)

knitr::include_graphics(paste0("analysis/", filename), dpi=dpi)

```

####  Interaction models

Specify chosen main effects model, compare to proposed interaction models
```{r include=FALSE}

# modsC[[7]] <- glm(as.formula(paste0(
#   resp, "~ species + nest_age + fdate" 
# )), data=dataMod, family=binomial)
# actually, compare to the main effects model as specified above (model 5) so it doesn't print twice

modsC[[7]] <- glm(as.formula(paste0(
  resp, "~ species * nest_age + fdate" 
)), data=dataMod, family=binomial)


modsC[[8]] <- glm(as.formula(paste0(
  resp, "~ species + nest_age * fdate" 
)), data=dataMod, family=binomial)


mod_diff(modsC[[5]], modsC[[7]])
mod_diff(modsC[[5]], modsC[[8]])
```

#### Analysis 2: including interaction models

```{r echo=FALSE}
# oddRat <- odd_rat(modsC)
aicTab <- aic_mod(modsC)
# aicTab

filename <- save_tab(aicTab)

knitr::include_graphics(paste0("analysis/", filename), dpi=dpi)

```
-----------------------------------------------------------------------------

## Excluding 2021 data

<!-- #### Initialize -->

<!-- Choose the data and response var, create list to store models -->

```{r echo=FALSE}
modsC2   <- list()
resp    <- "is_u"
dataMod <- ndGLM_scl2
```

#### Univariate models

```{r echo=FALSE, warning=FALSE}
# C_no2021 <- univar_mod(resp, dataMod)
# C_no2021[2]                               # show summaries
u_no2021 <- univar_mod(resp, dataMod)
# u_no2021[1]
# HF_inc2021[1] # this is giving weird output as HTML
tab <- u_no2021[[2]]
filename <- save_tab(tab)
# filename <- save_tab(u_no2021[2])

knitr::include_graphics(paste0("analysis/",filename), dpi=dpi)
```

```{r eval=FALSE, warning=FALSE, include=FALSE}
dataMod |> 
  select(c("is_u","species", "nest_age", "cam_fate", "fdate", "obs_int")) |>
  tbl_uvregression(
    
    method       = glm,
    y            = is_u,
    method.args  = list(family=binomial),
    exponentiate = TRUE
    
  )
```

#### Models
```{r}

m = "main effects"
```

<!-- 1.  Null and full models -->

```{r include=FALSE}
modsC2[[1]] <- glm(as.formula(paste0(
  resp,"~ species + nest_age + cam_fate + fdate + obs_int")),
  data=dataMod, family=binomial) # "fitted probabilities..." warning

modsC2[[2]] <- glm(as.formula(paste0(resp,"~ 1")), data=dataMod, family=binomial)

# cat("\n\n")
mod_diff(modsC2[[1]], modsC2[[2]])

```

<!-- 2.  Other models -->

```{r include=FALSE}
modsC2[[3]] <- glm(as.formula(paste0(

  resp, "~ nest_age"
)), data=dataMod, family=binomial)

mod_diff(modsC2[[1]], modsC2[[3]])

```

```{r include=FALSE}

modsC2[[4]] <- glm(as.formula(paste0(

  resp, "~ nest_age + species"
)), data=dataMod, family=binomial)

mod_diff(modsC2[[1]], modsC2[[4]])
```
```{r include=FALSE}

modsC2[[5]] <- glm(as.formula(paste0(

  resp, "~ nest_age + species + fdate"
)), data=dataMod, family=binomial)

mod_diff(modsC2[[1]], modsC2[[5]])
```

<!-- 3.  Interaction models -->

<!-- 4.  Analysis -->

```{r echo=FALSE}

aicC <- aic_mod(modsC2) # modsC definitely has 3 items, so why 5 names?
fn <- save_tab(aicC)

# knitr::include_graphics(paste0("analysis/", fn), dpi=(1566/6))
knitr::include_graphics(paste0("analysis/", fn), dpi=dpi)
```

--------------------------------------------------------------
<!-- ## QUESTION 4: If marked unknown in field, what affects misclassification? -->
<!-- ## QUESTION 4: If fate classified in field, what affects misclassification? -->

<!-- -   Remove nests assigned to a fate in the field -->
<!-- -   Remove nests marked unknown in the field -->
<!-- -   Response: HF_mis  -->

<!-- But then how is this different from question 1, where we were forced to exclude unknown fate nests? -->

<!-- ## Including 2021 data -->

<!-- ### Initialize -->

<!-- Choose the data and response var, create list to store models -->

```{r eval=FALSE, include=FALSE}
modsU <- list()
# resp = "misclass"
resp = "HF_mis"
# dataMod <- ndGLM_scl1[ndGLM_scl1$final_fate %in% c(7,8),]
dataMod <- ndGLM_scl1[ndGLM_scl1$cam_fate %in% c(0:6),]

# this can't be correct, because all U nests were mis-assigned
```

<!-- ### Univariate models -->

```{r eval=FALSE, include=FALSE}
U_inc2021 <- univar_mod(resp,dataMod)
U_inc2021                             # show summaries
# U_no2021
```

<!-- ### Models -->

<!-- ####  Null and full models -->

<!-- Using only "U" fate means cam_fate doesn't have all its levels -->

```{r eval=FALSE, include=FALSE}

modsU[[1]] <- glm(as.formula(paste0(
  resp,"~ species + nest_age + cam_fate + fdate + obs_int")), 
  data=dataMod, family=binomial) # "fitted probabilities..." warning

modsU[[2]] <- glm(as.formula(paste0(resp,"~ 1")), data=dataMod, family=binomial)

cat("\n\n")
anova(modsU[[1]], modsU[[2]], test="LRT")
```

<!-- #### Other models -->

```{r eval=FALSE, include=FALSE}
modsU[[3]] <- glm(as.formula(paste0(
  resp, "~ fdate + obs_int"
)), data=dataMod, family=binomial)

anova(modsU[[1]], modsU[[3]], test="LRT")

mod_diff(modsU[[1]], modsU[[3]])
```

<!-- #### Analysis -->

```{r eval=FALSE, include=FALSE}
aicU <- aic_mod(modsU)
filename <- save_tab(aicU)

knitr::include_graphics(paste0("analysis/", filename), dpi=dpi)
```

----------------------------------------------------------------------
-----------------------------------------------------------------------------------
<!-- ## Excluding 2021 data -->

<!-- #### Initialize -->

<!-- Choose the data and response var, create list to store models -->

<!-- ```{r echo=FALSE} -->
<!-- modsU <- list() -->
<!-- resp = "HF_mis" -->
<!-- # dataMod <- ndGLM_scl2[ndGLM_scl2$final_fate %in% c(7,8),] -->
<!-- dataMod <- ndGLM_scl2[ndGLM_scl2$final_fate %in% c(0:6),] -->

<!-- # this can't be correct, because all U nests were mis-assigned -->
<!-- ``` -->

<!-- #### Univariate models -->

<!-- ```{r include=FALSE} -->
<!-- U_no2021 <- univar_mod(resp,dataMod) -->
<!-- U_no2021                             # show summaries -->
<!-- # U_no2021 -->
<!-- ``` -->

<!-- #### Models -->

<!-- 1.  Null and full models -->

<!-- ```{r echo=FALSE} -->

<!-- ``` -->

<!-- 2.  Other models -->

<!-- ```{r echo=FALSE} -->

<!-- ``` -->

<!-- ##### Analysis -->

<!-- ```{r echo=FALSE} -->

<!-- ``` -->

----------------------------------------------------------------------

<!-- MISCLASSIFICATION (IN GENERAL) -->

<!-- ```{r} -->

<!-- mis_inc2021 <- univar_mod("misclass", ndGLM_scl1) -->

<!-- mis_no2021 <- univar_mod("misclass", ndGLM_scl2) -->

<!-- #  - all except species have p<0.25; cam_fate more difficult to interpret -->

<!-- ``` -->

<!-- ```{r} -->

<!-- #  -->

<!-- # Coefficient names:  -->

<!-- #   (Intercept)   speciesLETE      nest_age     cam_fate1     cam_fate2  -->

<!-- #     cam_fate3     cam_fate4     cam_fate6     fate_date       obs_int  -->

<!-- mods <- list()        # list to store candidate models -->

<!-- # resp <-  -->

<!-- # - null and full model -------------------------------------------------------- -->

<!-- mods[[1]] <- glm(misclass ~ species + nest_age + cam_fate + fate_date + obs_int, -->

<!--                  data=dataMod, family=binomial) # no error? but huge SE -->

<!-- coef(mods[[1]]) -->

<!-- coefNames <- names(coef(mods[[1]])) -->

<!-- mods[[2]] <- glm(misclass ~ 1, data=dataMod, family=binomial)  -->

<!-- coef(mods[[2]]) -->

<!-- # mods[[1]][which(setdiff(names(coef(mods[[1]])), names(coef(mods[[2]]))))] -->

<!-- # mods[[1]][setdiff(names(coef(mods[[1]])), names(coef(mods[[2]])))] -->

<!-- mods[[1]][setdiff(names(coef(mods[[1]])), names(coef(mods[[2]])))] -->

<!-- # setdiff(coef(mods[[1]]), coef(mods[[2]])) -->

<!-- mod_diff(mods[[1]], mods[[2]] ) -->

<!-- summary(mods[[1]]) # uh oh, now nothing looks significant -->

<!-- # coef(mods[[1]]) -->

<!-- anova(mods[[1]], mods[[2]], test = "LRT") -->

<!-- # but the full model is significantly different from the null model -->

<!-- ``` -->

<!-- Effects plots -->

<!-- ```{r} -->

<!-- # effects plots - do these work for this model? -->

<!-- # plot(allEffects(mods[[1]])) -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # - others --------------------------------------------------------------------- -->

<!-- # how to choose which ones to evaluate? -->

<!-- mods[[3]] <- glm(misclass ~ nest_age + fate_date, data=dataMod, family=binomial) -->

<!-- mod_diff(mods[[1]], mods[[3]]) -->

<!-- summary(mods[[3]]) -->

<!-- # excluding all non-signif vars from full model caused >20% change in age coef -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[3]], test="LRT") # significant difference using LRT -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # remove the vars one by one -->

<!-- mods[[4]] <- glm(misclass ~ species + nest_age  + fate_date + obs_int, -->

<!--                  data=dataMod, family=binomial) # take out cam fate -->

<!-- summary(mods[[4]]) -->

<!-- cat("\npercent difference in model coefficients (vs full model):\n") -->

<!-- (abs(coef(mods[[4]])-coef(mods[[1]])[-c(4:8)]) / coef(mods[[1]])[-c(4:8)]) -->

<!-- # need to make vectors the same length; remove non-shared columns -->

<!-- # changes multiple coefs by >20% -->

<!-- # huge change in fate_date coef might be bc it was tiny to begin with -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[4]], test="LRT") # close to significant change -->

<!-- ``` -->

<!-- ```{r} -->

<!-- #  -->

<!-- mods[[5]] <- glm(misclass ~  nest_age + fate_date + obs_int, -->

<!--                  data=dataMod, family=binomial) # remove species and cam_fate -->

<!-- # leaves only numeric predictors -->

<!-- summary(mods[[5]]) -->

<!-- # is it % difference from previous model or from full model? -->

<!-- # examine % difference in coefficients from removing species and cam_fate -->

<!-- cat("\npercent difference in model coefficients (vs full model):\n") -->

<!-- (abs(coef(mods[[5]])-coef(mods[[1]])[-c(2, 4:8)]) / coef(mods[[1]])[-c(2, 4:8)]) -->

<!-- # changes age coef by > 20% -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[5]], test="LRT") # almost significant difference -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # - interactions? -------------------------------------------------------------- -->

<!-- # need to have biological justification -->

<!-- # DON'T interpret the main effects by themselves when there's evidence of -->

<!-- # an interaction! -->

<!-- # looking at effects of interactions should only be done in context of main effects -->

<!-- # does the date change the effect of age at classification (age at hatch/fail)? -->

<!-- # i.e. is the effect of nest age on misclassification dependent on the date of  -->

<!-- # classification? -->

<!-- # add interaction terms one by one and evaluate -->

<!-- #  -->

<!-- # Use boxplots to look for interactions with categorical variables -->

<!-- # x2 must be a factor; also, some have too many levels -->

<!-- #  -->

<!-- # y = "was_mis" -->

<!-- # x1 = "obs_int" -->

<!-- # x2 = "species" #  -->

<!-- #  # ggplot(dataMod, aes(x=.data[[y]], y=.data[[x1]])) +                                                                                                                                                                                                                                                                                                                        #   geom_boxplot(aes(color=.data[[x2]])) # # cam_fate has too many categories for this to work with it, but works for species -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # actually, want y-axis to be the probability -->

<!-- # can choose log-odds scale (linear) or probability scale (sigmoid) -->

<!-- mods[[6]] <- glm(misclass ~ nest_age * fate_date, data=dataMod, family=binomial) -->

<!-- cat("\npercent difference in model coefficients (vs full model)\n") -->

<!-- (abs(coef(mods[[6]])-coef(mods[[1]])[-c(2, 4:8)]) / coef(mods[[1]])[-c(2, 4:8)]) -->

<!-- # how do I change this to make it work for the interaction models? -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[6]], test="LRT") -->

<!-- ``` -->

<!-- ```{r} -->

<!-- mods[[7]] <- glm(misclass ~ cam_fate + obs_int + nest_age * fate_date, -->

<!--                  data=dataMod, -->

<!--                  family=binomial) # got the fitted probabilities error again -->

<!-- cat("\npercent difference in model coefficients (vs full model)\n") -->

<!-- (abs(coef(mods[[7]])-coef(mods[[1]])[-c(2)]) / coef(mods[[1]])[-c(2)]) -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[7]], test="LRT")  -->

<!-- ``` -->

<!-- ```{r} -->

<!-- mods[[8]] <- glm(misclass ~ species + cam_fate + obs_int + nest_age * fate_date, -->

<!--                  data=dataMod, -->

<!--                  family=binomial) # got the fitted probabilities error again -->

<!-- cat("\npercent difference in model coefficients (vs full model)\n") -->

<!-- (abs(coef(mods[[7]])-coef(mods[[1]])[-c(2)]) / coef(mods[[1]])[-c(2)]) -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[8]], test="LRT")  -->

<!-- ``` -->

<!-- ```{r} -->

<!-- mods[[9]] <- glm(misclass ~ species + obs_int + nest_age + fate_date * cam_fate , -->

<!--                  data=dataMod, -->

<!--                  family=binomial) # got the fitted probabilities error again -->

<!-- cat("\npercent difference in model coefficients (vs full model)\n") -->

<!-- (abs(coef(mods[[9]])-coef(mods[[1]])[-c(2)]) / coef(mods[[1]])[-c(2)]) -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[9]], test="LRT")  -->

<!-- ``` -->

<!-- ```{r} -->

<!-- mods[[10]] <- glm(misclass ~ species * obs_int + nest_age + fate_date + cam_fate , -->

<!--                  data=dataMod, -->

<!--                  family=binomial) # got the fitted probabilities error again -->

<!-- cat("\npercent difference in model coefficients (vs full model)\n") -->

<!-- (abs(coef(mods[[10]])-coef(mods[[1]])[-c(2)]) / coef(mods[[1]])[-c(2)]) -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[10]], test="LRT")  -->

<!-- ``` -->

<!-- ```{r} -->

<!-- mods[[11]] <- glm(misclass ~ species * nest_age + obs_int + fate_date + cam_fate , -->

<!--                  data=dataMod, -->

<!--                  family=binomial) # got the fitted probabilities error again -->

<!-- cat("\npercent difference in model coefficients (vs full model)\n") -->

<!-- (abs(coef(mods[[11]])-coef(mods[[1]])[-c(2)]) / coef(mods[[1]])[-c(2)]) -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[11]], test="LRT")  -->

<!-- ``` -->

<!-- ```{r} -->

<!-- mods[[12]] <- glm(misclass ~ species  * cam_fate + obs_int + nest_age + fate_date, -->

<!--                  data=dataMod, -->

<!--                  family=binomial) # got the fitted probabilities error again -->

<!-- cat("\npercent difference in model coefficients (vs full model)\n") -->

<!-- (abs(coef(mods[[12]])-coef(mods[[1]])[-c(2)]) / coef(mods[[1]])[-c(2)]) -->

<!-- cat("\n\n") -->

<!-- anova(mods[[1]], mods[[12]], test="LRT")  -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # Odds ratios for all models -->

<!-- cat("Odds ratios for all models:\n\n") -->

<!-- oddrats <- paste(sapply(mods, function(x) exp(x$coefficients)), sep=' ') -->

<!-- oddrats -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # Probability ----------------------------------------------------------------- -->

<!-- # plogis(predict(fitted_model)) should convert the log-odds output of the model -->

<!-- # to a probability; use predict(fitted_model, type="response") to see prob -->

<!-- # of your data values.. can also calculate probs by hand if you want -->

<!-- dataMod$probfull <- plogis(predict(mods[[1]])) -->

<!-- dataMod$prob5 <- plogis(predict(mods[[5]]))   -->

<!-- y = "probfull" -->

<!-- x1 = "nest_age" -->

<!-- x2 = "species" -->

<!-- ggplot(dataMod, aes(x=.data[[x1]], y=.data[[y]])) + -->

<!--   geom_point(aes(color=.data[[x2]])) +  -->

<!--   geom_abline() -->

<!-- #geom_boxplot(aes(color=.data[[x2]])) -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # Analysis of Deviance -------------------------------------------------------- -->

<!-- # # from R docs for anova.manyglm (mvabund package): -->

<!-- # "If you do not have a specific hypothesis of primary interest that you want to  -->

<!-- # test, and are instead interested in which model terms are statistically  -->

<!-- # significant, then the summary.manyglm function is more appropriate" -->

<!-- # "WARNING: -->

<!-- # The comparison between two or more models by anova.manyglm will only be valid  -->

<!-- # if they are fitted to the same dataset. This may be a problem if there are  -->

<!-- # missing values and R's default of na.action = na.omit is used" -->

<!-- # so, remove NAs first so you have a consistent dataset throughout -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # AIC and BIC ----------------------------------------------------------------- -->

<!-- dp <- function(x) deparse(x, width.cutoff=150) -->

<!-- modEQ <- paste( -->

<!--   sapply(mods,  -->

<!--          function(x) str_extract(dp(x$call), "(?<=~\\s).+(?=,\\sfamily)") -->

<!--   ), sep = " ") -->

<!-- nestBIC <- bictab(cand.set = mods, modnames = modEQ, sort = T) # include VIF? -->

<!-- nestBIC -->

<!-- # AIC and BIC are disagreeing more and more as I add back nests. -->

<!-- # or maybe it's the centered variables -->

<!-- BICtab <- gt(nestBIC) |>  -->

<!--   tab_header(title="BIC scores") |> -->

<!--   tab_style(style =  -->

<!--               cell_text(size="small"), -->

<!--             locations = cells_body()) -->

<!-- BICtab  # view table -->

<!-- nestAIC <- aictab(cand.set = mods, modnames = modEQ, sort = T) -->

<!-- nestAIC -->

<!-- AICtab <- gt(nestAIC) |>  -->

<!--   tab_header(title="AIC scores") |> -->

<!--   tab_style(style =  -->

<!--               cell_text(size="small"), -->

<!--             locations= cells_body()) -->

<!-- AICtab -->

<!-- #ab <- bind_rows(AICtab,BICtab) # doesn't work -->

<!-- ab3 <- bind_rows(nestAIC, nestBIC) # not quite what I need  -->

<!-- # need to group by modname -->

<!-- ab3 <- ab3 %>% -->

<!--   replace(is.na(.), 0) %>% -->

<!--   group_by(Modnames) %>% -->

<!--   summarize(across(where(is.numeric), c(sum, mean))) -->

<!-- deltaTab <- ab3 %>% -->

<!--   select(c(Modnames, K_1, Delta_AICc_1, Delta_BIC_1, LL_2,)) %>% -->

<!--   arrange(Delta_AICc_1) -->

<!-- abTab <- ab3 %>% -->

<!--   select(c(Modnames, K_1, AICc_1, AICcWt_1, BIC_1, BICWt_1, LL_2)) -->

<!-- deltaTab1 <- gt(deltaTab) |> -->

<!--   tab_header(title="Summary of Information Criteria") |> -->

<!--   tab_style(style=cell_text(size="small"), -->

<!--             locations=cells_body()) -->

<!-- abTab1 <- gt(abTab) |> -->

<!--   tab_header(title="Summary of Information Criteria") |> -->

<!--   tab_style(style=cell_text(size="sma -->

<!--                             ll"), -->

<!--             locations=cells_body()) -->

<!-- # use gtsave() or as_word() to export - actually, just use gtsave() w/ file type -->

<!-- #as_word(BICtab) # output I don't know how to use -->

<!-- deltaTab1 -->

<!-- now = format(Sys.time(), "%m%d_%H%M") -->

<!-- tab <- deltaTab1 # which table to save to file -->

<!-- file_name <- paste0(names(tab)[1], "aicbic_", now, ".rtf") -->

<!-- gtsave(tab, file_name, path="analysis/") -->

<!-- # at least AIC and BIC vals seem to agree (mostly) -->

<!-- ``` -->

<!-- ```{r} -->

<!-- # Nice-looking tables ---------------------------------------------------------- -->

<!-- tbl_regression(mods[[1]], exponentiate=TRUE) # best model w/o same data -->

<!-- tbl_regression(mods[[3]], exponentiate = TRUE) # best model w/ same data -->

<!-- tbl_regression(mods[[5]], exponentiate=TRUE) # full model -->

<!-- # all of the categorical vars look insane... -->

<!-- tab <- mods[[1]] %>% -->

<!--   tbl_regression(exponentiate=TRUE) %>% -->

<!--   add_global_p() %>% -->

<!--   bold_p() -->

<!-- # keep getting 50 or more warnings for model 1 -  -->

<!-- # "glm.fit: fitted probabilities numerically 0 or 1 occurred" -->

<!-- # ugh, not this again -->

<!-- # didn't do anything when I first ran the model... -->

<!-- # why is it only the categorical vars that create the craziness? -->

<!-- # or is it just species? try the one w/o species -->

<!-- tab2 <- mods[[12]] %>% -->

<!--   tbl_regression(exponentiate=TRUE) %>% -->

<!--   add_global_p() %>% -->

<!--   bold_p() -->

<!-- # nope, still getting 50+ warnings - same ones -->

<!-- tab2 -->

<!-- tab3 <- mods[[5]] %>% -->

<!--   tbl_regression(exponentiate=TRUE) %>% -->

<!--   add_global_p() %>% -->

<!--   bold_p() -->

<!-- tab3 -->

<!-- ``` -->

<!-- How far off were we on hatch success/failure rate? -->

<!-- remove 2021? or add year effect and see if it's different? very few -->

<!-- cameras from months other than June - afraid of bias also very few nest -->

<!-- ages and relatively many U fates bc of poor monitoring long nest check -->

<!-- intervals pretty sure this makes them MNAR bc hatched nests are more -->

<!-- likely to have age remove Holly Beach?? -->

<!-- <!-- # Create new list of models in order ------------------------------------------- -->

--\>

<!-- <!-- # logistic regression looks at changes in the probability y=1 for different -->

--\>

<!-- <!-- # values of x; error terms, like response, have a binomial (nonnormal) distribution -->

--\>

<!-- <!-- # the logit link function transforms the binomially-distributed data to resemble -->

--\>

<!-- <!-- # a linear model; [-inf < y < inf] even though [0 < prob < 1] -->

--\>

<!-- <!-- # in some models, check for collinearity -->

--\>

<!-- <!-- # sometimes perfect/quasi-perfect separation will lead to errors -->

--\>

<!-- <!-- # (see previous versions) -->

--\>

<!-- <!-- # simple logistic regression: -->

--\>

<!-- <!-- # beta_0 is the value of the regression equation when x = 0 -->

--\>

<!-- <!-- # if beta_1 == 0, there is no relationship btw predictor and response -->

--\>

<!-- <!-- # use Wald tests (for larger n) or likelihood ratio test -->

--\>

<!-- <!-- # also compare deviances of the 2 models (full and null) -->

--\>

<!-- <!-- # in multiple logistic regression: -  -->

--\>

<!-- <!-- # odds ratio = prob(success) / prob(failure) = p/(1-p) -->

--\>

<!-- <!-- # taking the log odds ratio allows linear model with predictor(s) -->

--\>

<!-- <!-- # make sure cam_fate is coded as a factor even though the values are numeric -->

--\>

<!-- <!-- # you can add VIF or other overdispersion param to the AIC/BIC table (arg c.hat) -->

--\>

<!-- <!-- # when I use the same data for all models (with all NA rows removed), I get -->

--\>

<!-- <!-- # a different order of models, and my first disagreement between BIC and AIC -->

--\>

<!-- <!-- # odds ratio of x = change in the probability of y for a 1-unit change in x -->

--\>

<!-- <!-- # for scaled predictors, use 1-stdev change instead of 1-unit change -->

--\>

<!-- <!-- # there's also an oddsratio package -->

--\>

<!-- <!-- # make sure categorical vars (like cam fate) are coded as factors, and continuous -->

--\>

<!-- <!-- # vars are coded as numeric -->

--\>

<!-- <!-- # convert logits to probabilities: exp(logit)/(1+exp(logit)) # for factors only -->

--\>

<!-- <!-- # this can help in visualizing results of logistic regression -->

--\>

<!-- <!-- #dataMod <- ndGLM.1 -->

--\>

<!-- ## R Markdown -->

<!-- This is an R Markdown document. Markdown is a simple formatting syntax -->

<!-- for authoring HTML, PDF, and MS Word documents. For more details on -->

<!-- using R Markdown see <http://rmarkdown.rstudio.com>. -->

<!-- When you click the **Knit** button a document will be generated that -->

<!-- includes both content as well as the output of any embedded R code -->

<!-- chunks within the document. You can embed an R code chunk like this: -->

<!-- ```{r cars} -->

<!-- summary(cars) -->

<!-- ``` -->

<!-- ## Including Plots -->

<!-- You can also embed plots, for example: -->

<!-- ```{r pressure, echo=FALSE} -->

<!-- plot(pressure) -->

<!-- ``` -->

<!-- Note that the `echo = FALSE` parameter was added to the code chunk to -->

<!-- prevent printing of the R code that generated the plot. -->
